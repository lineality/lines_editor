// useful
    // Add .txt extension if no extension provided
    let mut buf = [0u8; 8]; // Adjust size as needed
    let filename_bytes;

    let filename = if trimmed.contains('.') {
        trimmed
    } else {
        let txt_suffix = b".txt";
        let trimmed_bytes = trimmed.as_bytes();

        if trimmed_bytes.len() + txt_suffix.len() <= buf.len() {
            buf[..trimmed_bytes.len()].copy_from_slice(trimmed_bytes);
            buf[trimmed_bytes.len()..trimmed_bytes.len() + txt_suffix.len()]
                .copy_from_slice(txt_suffix);

            filename_bytes = &buf[..trimmed_bytes.len() + txt_suffix.len()];
            std::str::from_utf8(filename_bytes).unwrap()
        } else {
            trimmed // Fallback if name too long
        }
    };

    Ok(filename.to_string())

to use:
                #[cfg(debug_assertions)]
                eprintln!("e: {}", e);



/// Creates a timestamp string with full year prefix for archive file naming
///
/// # Purpose
/// Generates a consistent, sortable timestamp string for archive filenames
/// that works identically across all platforms (Windows, Linux, macOS).
/// Includes full 4-digit year prefix for better year identification.
///
/// # Arguments
/// * `time` - The SystemTime to format (typically SystemTime::now())
///
/// # Returns
/// * `String` - Timestamp in format: "YYYY_YY_MM_DD_HH_MM_SS"
///
/// # Format Specification
/// - YYYY: Four-digit year (0000-9999)
/// - YY: Two-digit year (00-99)
/// - MM: Two-digit month (01-12)
/// - DD: Two-digit day (01-31)
/// - HH: Two-digit hour in 24-hour format (00-23)
/// - MM: Two-digit minute (00-59)
/// - SS: Two-digit second (00-59)
///
/// # Examples
/// - "2024_24_01_15_14_30_45" for January 15, 2024 at 2:30:45 PM
/// - "2023_23_12_31_23_59_59" for December 31, 2023 at 11:59:59 PM
///
/// # Platform Consistency
/// This function produces identical output on all platforms by using
/// epoch-based calculations rather than platform-specific date commands.
fn create_archive_timestamp(time: SystemTime) -> String {
    // Get duration since Unix epoch
    let duration_since_epoch = match time.duration_since(UNIX_EPOCH) {
        Ok(duration) => duration,
        Err(_) => {
            // System time before Unix epoch - use fallback
            eprintln!("Warning: System time is before Unix epoch, using fallback timestamp");
            return String::from("1970_70_01_01_00_00_00");
        }
    };

    let total_seconds = duration_since_epoch.as_secs();

    // Use the accurate date calculation
    let (year, month, day, hour, minute, second) =
        epoch_seconds_to_datetime_components(total_seconds);

    // Assertion 1: Validate year range
    const MAX_REASONABLE_YEAR: u32 = 9999;
    if year > MAX_REASONABLE_YEAR {
        eprintln!(
            "Warning: Year {} exceeds maximum reasonable value {}. Using fallback.",
            year, MAX_REASONABLE_YEAR
        );
        return String::from("9999_99_12_31_23_59_59");
    }

    // Assertion 2: Validate all components are in expected ranges
    if month < 1 || month > 12 || day < 1 || day > 31 || hour > 23 || minute > 59 || second > 59 {
        eprintln!(
            "Warning: Invalid date/time components: {}-{:02}-{:02} {:02}:{:02}:{:02}",
            year, month, day, hour, minute, second
        );
        return String::from("1970_70_01_01_00_00_00"); // Safe fallback
    }

    // Format as YYYY_YY_MM_DD_HH_MM_SS
    format!(
        "{:04}_{:02}_{:02}_{:02}_{:02}_{:02}_{:02}",
        year,       // Four-digit year
        year % 100, // Two-digit year
        month,
        day,
        hour,
        minute,
        second
    )
}

/// Moves cursor to position BEFORE next syntax character (Vim-style 'e' command)
///
/// # Purpose
/// Implements 'e' command for word navigation. Moves cursor forward to the
/// position BEFORE the next syntax character. This positions cursor at the
/// last non-syntax character of current word.
/// Also counts newlines to allow window scrolling without rebuild.
///
/// # Algorithm
/// 1. Move forward 2 bytes (assumption: next byte is syntax, skip it)
/// 2. Loop (max 64 iterations):
///    - Peek ahead 1 byte (look at next position)
///    - If next byte is syntax OR EOF → STOP (cursor is positioned)
///    - If next byte is non-syntax → move cursor forward 1 byte, continue
///    - If newline encountered during move: increment counter
/// 3. Return final byte offset AND newline count
///
/// # Arguments
/// * `file_path` - Absolute path to file being edited
/// * `current_byte_offset` - Current cursor position (0-indexed byte offset)
/// * `file_size` - Total file size in bytes (for EOF detection)
///
/// # Returns
/// * `Ok((new_byte_offset, newlines_crossed))` where:
///   - `new_byte_offset` - Position before next syntax char (or EOF)
///   - `newlines_crossed` - Number of 0x0A bytes encountered during move
/// * `Err(LinesError)` - File read error
///
/// # Edge Cases
/// - Cursor at EOF: returns `(EOF_pos, 0)` (no movement possible)
/// - Cursor already before syntax: moves past it to next word end
/// - Multiple syntax chars in row: skips first, stops at next
/// - Crosses newline: counts it, positions before next syntax
/// - File with no syntax: moves 64+ bytes forward (iteration limit)
///
/// # Memory Safety
/// - Stack-only: 1-byte read buffer
/// - No dynamic allocation
/// - Bounded iterations (max 64)
///
/// # Defensive Programming
/// - Iteration limit prevents infinite loops (NASA Rule #2)
/// - All read errors propagated
/// - Saturating arithmetic prevents underflow/overflow
/// - Peek-ahead safely handles EOF (no buffer overflow)
/// - Byte-level syntax check safe for UTF-8
///
/// # Example
/// ```ignore
/// // File: "hello world"
/// // Cursor at byte 0 (on 'h')
/// let (new_pos, newlines) = move_word_end(path, 0, 11)?;
/// // Moves forward 2 (to 'l'), then peeks at 'l' (non-syntax)
/// // Continues moving: 'l'->'o'->space (stop before space)
/// // Returns (4, 0) - positioned on 'o'
/// ```
pub fn move_word_end(
    file_path: &Path,
    current_byte_offset: u64,
    file_size: u64,
) -> Result<(u64, usize)> {
    // Returns: (new_byte_offset, newlines_crossed)

    // =========================================================================
    // INPUT VALIDATION
    // =========================================================================

    // Debug assert: path should be valid
    debug_assert!(
        !file_path.as_os_str().is_empty(),
        "File path cannot be empty"
    );

    // Test assert: path should be valid
    #[cfg(test)]
    assert!(
        !file_path.as_os_str().is_empty(),
        "File path cannot be empty"
    );

    // Production check: path empty
    if file_path.as_os_str().is_empty() {
        return Err(LinesError::InvalidInput("File path cannot be empty".into()));
    }

    // Debug assert: offset should not exceed file size
    debug_assert!(
        current_byte_offset <= file_size,
        "Cursor offset {} exceeds file size {}",
        current_byte_offset,
        file_size
    );

    // Test assert: offset should not exceed file size
    #[cfg(test)]
    assert!(
        current_byte_offset <= file_size,
        "Cursor offset {} exceeds file size {}",
        current_byte_offset,
        file_size
    );

    // Production check: offset exceeds file size
    if current_byte_offset > file_size {
        return Err(LinesError::InvalidInput(format!(
            "Cursor offset {} exceeds file size {}",
            current_byte_offset, file_size
        )));
    }

    // =========================================================================
    // EARLY RETURN: ALREADY AT EOF
    // =========================================================================

    // If cursor already at EOF, nowhere to move to
    if current_byte_offset >= file_size {
        return Ok((current_byte_offset, 0)); // Stay at EOF, no newlines
    }

    // =========================================================================
    // OPEN FILE FOR READING
    // =========================================================================

    let mut file = File::open(file_path).map_err(|e| {
        log_error(
            &format!("Cannot open file for word end movement: {}", e),
            Some("move_word_end"),
        );
        LinesError::Io(e)
    })?;

    // =========================================================================
    // INITIALIZE STATE
    // =========================================================================

    // Pre-allocated 1-byte buffer (stack only, no allocation)
    let mut byte_buffer: [u8; 1] = [0];

    // Current position during iteration
    let mut current_pos: u64 = current_byte_offset;

    // Newline counter (for window scrolling)
    let mut newlines_crossed: usize = 0;

    // =========================================================================
    // STEP 1: MOVE FORWARD 2 BYTES (ASSUMPTION: NEXT IS SYNTAX, SKIP IT)
    // =========================================================================

    // First move: skip 1 byte
    current_pos = current_pos.saturating_add(1);
    if current_pos >= file_size {
        return Ok((current_pos, newlines_crossed));
    }

    // Second move: skip another byte (assumption: it's syntax)
    // But we need to track if it's a newline
    file.seek(io::SeekFrom::Start(current_pos)).map_err(|e| {
        log_error(
            &format!(
                "Cannot seek to byte {} for word end initial move: {}",
                current_pos, e
            ),
            Some("move_word_end"),
        );
        LinesError::Io(e)
    })?;

    match file.read(&mut byte_buffer) {
        Ok(0) => {
            // EOF at this position
            return Ok((current_pos, newlines_crossed));
        }
        Ok(1) => {
            // Track if we're moving past a newline
            if byte_buffer[0] == b'\n' {
                newlines_crossed += 1;
            }
            current_pos = current_pos.saturating_add(1);
        }
        Ok(n) => {
            let error_msg = format!(
                "Unexpected read count {} at byte {} (expected 0 or 1)",
                n, current_pos
            );
            log_error(&error_msg, Some("move_word_end"));
            return Err(LinesError::Io(io::Error::new(
                io::ErrorKind::InvalidData,
                error_msg,
            )));
        }
        Err(e) => {
            log_error(
                &format!("Read error at byte {}: {}", current_pos, e),
                Some("move_word_end"),
            );
            return Err(LinesError::Io(e));
        }
    }

    // Check if we've gone past EOF after second move
    if current_pos >= file_size {
        return Ok((current_pos, newlines_crossed));
    }

    // =========================================================================
    // MAIN LOOP: PEEK AHEAD UNTIL NEXT BYTE IS SYNTAX
    // =========================================================================

    let mut iteration: usize = 0;

    loop {
        // Defensive: Check iteration limit
        if iteration >= WORD_MOVE_MAX_ITERATIONS {
            // Hit iteration limit - stop here
            log_error(
                &format!(
                    "Word end movement hit iteration limit at byte {}",
                    current_pos
                ),
                Some("move_word_end"),
            );
            return Ok((current_pos, newlines_crossed));
        }

        iteration += 1;

        // ===================================================================
        // PEEK AHEAD TO NEXT BYTE (BEFORE MOVING)
        // ===================================================================

        // Calculate next position
        let next_pos = current_pos.saturating_add(1);

        // Check if next position would be past EOF
        if next_pos >= file_size {
            // Next byte would be past EOF - stop here (cursor at current position)
            return Ok((current_pos, newlines_crossed));
        }

        // ===================================================================
        // READ NEXT BYTE (PEEK AHEAD)
        // ===================================================================

        // Seek to next position
        file.seek(io::SeekFrom::Start(next_pos)).map_err(|e| {
            log_error(
                &format!("Cannot seek to byte {} for word end peek: {}", next_pos, e),
                Some("move_word_end"),
            );
            LinesError::Io(e)
        })?;

        // Read one byte
        match file.read(&mut byte_buffer) {
            Ok(0) => {
                // EOF at next position - stop here
                return Ok((current_pos, newlines_crossed));
            }
            Ok(1) => {
                // Got one byte - check if it's syntax
                let next_byte = byte_buffer[0];

                match is_syntax_char(next_byte) {
                    Ok(true) => {
                        // Next byte IS syntax - STOP HERE (cursor stays before it)
                        return Ok((current_pos, newlines_crossed));
                    }
                    Ok(false) => {
                        // Next byte is non-syntax - move cursor forward to it
                        current_pos = next_pos;

                        // Check if we just moved through a newline
                        if next_byte == b'\n' {
                            newlines_crossed += 1;
                        }

                        // Continue loop to peek at the byte after this one
                        continue;
                    }
                    Err(e) => {
                        // Error checking syntax (shouldn't happen, but handle it)
                        log_error(
                            &format!("Error checking syntax at byte {}: {}", next_pos, e),
                            Some("move_word_end"),
                        );
                        return Err(e);
                    }
                }
            }
            Ok(n) => {
                // Unexpected: read() returned more than 1 byte for 1-byte buffer
                let error_msg = format!(
                    "Unexpected read count {} at byte {} (expected 0 or 1)",
                    n, next_pos
                );
                log_error(&error_msg, Some("move_word_end"));
                return Err(LinesError::Io(io::Error::new(
                    io::ErrorKind::InvalidData,
                    error_msg,
                )));
            }
            Err(e) => {
                // Read error - propagate
                log_error(
                    &format!("Read error at byte {}: {}", next_pos, e),
                    Some("move_word_end"),
                );
                return Err(LinesError::Io(e));
            }
        }
    }
}
/// Checks if the byte at a specific file position is a newline character
///
/// # Purpose
/// Safe, defensive helper function for peek-ahead operations. Used by movement
/// commands to detect when cursor would cross a line boundary without
/// moving or modifying state.
///
/// # Design Philosophy
/// - Single responsibility: just peek at one byte, answer yes/no
/// - Fail-safe: returns false on any error (doesn't panic or halt)
/// - Memory safe: no allocation, bounded I/O
/// - Used by: move_word_forward, move_word_end, move_word_back, and any other
///   movement that needs to detect line boundaries
///
/// # Arguments
/// * `file_path` - Absolute path to file being checked
///   - Must exist and be readable
///   - Defensive: caller responsible for validation
/// * `byte_pos` - Byte offset to check (0-indexed)
///   - Can be any value including >= file_size
///   - Defensive: out-of-bounds positions safely return false
/// * `file_size` - Total file size in bytes
///   - Used to validate byte_pos is in range
///   - If byte_pos >= file_size, returns false (EOF, not newline)
///
/// # Returns
/// * `Ok(true)` - Byte at position is 0x0A (newline)
/// * `Ok(false)` - Byte at position is not newline (any other byte or out-of-bounds)
/// * `Err(LinesError::Io)` - File operations failed (open, seek, read errors)
///
/// # Edge Cases Handled
/// - `byte_pos >= file_size` → returns `Ok(false)` (EOF is not newline)
/// - `byte_pos == file_size - 1` → reads last byte correctly
/// - File read returns 0 bytes → returns `Ok(false)` (EOF, not newline)
/// - File seek fails → returns `Err` (I/O error, logged)
/// - File read fails mid-operation → returns `Err` (I/O error, logged)
/// - Empty file (size 0) → returns `Ok(false)` (no bytes to read)
///
/// # Memory Safety
/// - Stack-only: 1-byte buffer allocated on stack
/// - No dynamic allocation
/// - No heap growth
/// - Single file open/seek/read/close per call
/// - Safe for UTF-8: newline is ASCII 0x0A, no multi-byte collision possible
///
/// # Performance
/// - Time: O(1) - single byte read (or fail fast)
/// - Space: O(1) - fixed 1-byte buffer
/// - I/O: 1 file open, 1 seek, 1 read, 1 close
/// - Suitable for calling in loops (bounded, cached pattern: peek before move)
///
/// # Defensive Programming
/// - All I/O errors logged with context
/// - No unwrap() or panic() calls
/// - Saturating arithmetic prevents overflow
/// - Early returns for out-of-bounds
/// - No assumptions about file state
///
/// # Use Cases
///
/// **Case 1: Peek-ahead in word movement**
/// ```ignore
/// // Before moving cursor, check if next byte is newline
/// if is_newline_at_position(&file_path, current_pos + 1, file_size)? {
///     // Crossed line boundary - use line nav instead
///     execute_command(state, Command::GotoLineStart)?;
///     execute_command(state, Command::MoveDown(1))?;
/// } else {
///     // Normal character movement
///     cursor.col += 1;
/// }
/// ```
///
/// **Case 2: Loop detection in move_word_forward**
/// ```ignore
/// while remaining_moves > 0 {
///     let next_pos = current_pos + 1;
///
///     if is_newline_at_position(&file_path, next_pos, file_size)? {
///         // Hit newline - stop or handle line crossing
///         return Ok((current_pos, newlines_crossed));
///     }
///
///     current_pos = next_pos;
///     remaining_moves -= 1;
/// }
/// ```
///
/// **Case 3: Integration with MoveRight command**
/// ```ignore
/// // In MoveRight loop: peek before scrolling right
/// if is_newline_at_position(&file_path, next_byte_pos, file_size)? {
///     execute_command(state, Command::GotoLineStart)?;
///     execute_command(state, Command::MoveDown(1))?;
/// } else {
///     state.tui_window_horizontal_utf8txt_line_char_offset += 1;
/// }
/// ```
///
/// # Integration Points
/// - `move_word_forward()`: Peek ahead to detect line crossing
/// - `move_word_end()`: Peek in loop to stop at syntax on next line
/// - `move_word_back()`: Peek backward to detect line crossing (reverse)
/// - `Command::MoveRight`: Peek before scrolling right (existing code)
/// - Any future movement command that needs line boundary detection
///
/// # Testing Strategy
/// Test with:
/// - File with newlines at various positions
/// - Empty file (no bytes)
/// - File with no newlines (single line)
/// - File with multiple consecutive newlines
/// - Position at EOF
/// - Position past EOF
/// - Position 0 (start of file)
/// - Last byte of file (EOF-1)
/// - Read-only files
/// - Binary files containing 0x0A bytes (not text)
///
/// # Performance Characteristics
/// - Suitable for per-move peek operations
/// - Not suitable for bulk newline scanning (use count_lines_in_file for that)
/// - Cost-benefit: single byte I/O vs. avoiding line-crossing bugs
///
/// # Error Policy
/// Following project error handling philosophy:
/// - File errors propagated (caller handles via ?)
/// - Logging happens before returning error
/// - Never silently swallows errors
/// - Caller responsible for retry/recovery logic
///
/// # Future Enhancement
/// Could cache results if same file peeked repeatedly, but:
/// - File may change between edits
/// - Invalidation logic complex
/// - Current per-call overhead minimal
/// - Premature optimization: keep simple unless profiling shows issue
///
pub fn is_newline_at_position(file_path: &Path, byte_pos: u64, file_size: u64) -> Result<bool> {
    // =========================================================================
    // INPUT VALIDATION
    // =========================================================================

    // Debug assert: path should be valid
    debug_assert!(
        !file_path.as_os_str().is_empty(),
        "File path cannot be empty in is_newline_at_position"
    );

    // Test assert: path should be valid
    #[cfg(test)]
    assert!(
        !file_path.as_os_str().is_empty(),
        "File path cannot be empty in is_newline_at_position"
    );

    // Production check: path empty
    if file_path.as_os_str().is_empty() {
        return Err(LinesError::InvalidInput("File path cannot be empty".into()));
    }

    // =========================================================================
    // EARLY RETURN: OUT OF BOUNDS
    // =========================================================================

    // Defensive: If position is at or past EOF, it's not a newline
    // This is the most common "false" case
    if byte_pos >= file_size {
        return Ok(false);
    }

    // =========================================================================
    // OPEN FILE FOR READING
    // =========================================================================

    let mut file = File::open(file_path).map_err(|e| {
        log_error(
            &format!(
                "Cannot open file to check for newline at byte {}: {}",
                byte_pos, e
            ),
            Some("is_newline_at_position"),
        );
        LinesError::Io(e)
    })?;

    // =========================================================================
    // SEEK TO POSITION AND READ SINGLE BYTE
    // =========================================================================

    // Pre-allocated 1-byte buffer (stack only, no allocation)
    let mut byte_buffer: [u8; 1] = [0];

    // Seek to the position we want to check
    file.seek(io::SeekFrom::Start(byte_pos)).map_err(|e| {
        log_error(
            &format!(
                "Cannot seek to byte {} in is_newline_at_position: {}",
                byte_pos, e
            ),
            Some("is_newline_at_position"),
        );
        LinesError::Io(e)
    })?;

    // Read one byte
    match file.read(&mut byte_buffer) {
        Ok(0) => {
            // EOF reached - no byte at this position (shouldn't happen after bounds check)
            log_error(
                &format!(
                    "Unexpected EOF when reading at byte {} (file_size was {})",
                    byte_pos, file_size
                ),
                Some("is_newline_at_position"),
            );
            Ok(false)
        }
        Ok(1) => {
            // Got one byte - check if it's a newline
            // Newline is ASCII 0x0A - safe single-byte check (no UTF-8 collision)
            Ok(byte_buffer[0] == b'\n')
        }
        Ok(n) => {
            // Unexpected: read() returned more than 1 byte for 1-byte buffer
            // This should never happen in safe Rust
            let error_msg = format!(
                "Unexpected read count {} at byte {} (expected 0 or 1)",
                n, byte_pos
            );
            log_error(&error_msg, Some("is_newline_at_position"));
            Err(LinesError::Io(io::Error::new(
                io::ErrorKind::InvalidData,
                error_msg,
            )))
        }
        Err(e) => {
            // Read error - propagate with context
            log_error(
                &format!(
                    "Read error at byte {} in is_newline_at_position: {}",
                    byte_pos, e
                ),
                Some("is_newline_at_position"),
            );
            Err(LinesError::Io(e))
        }
    }
}

    /// Retrieves the byte range for a display row
    ///
    /// # Purpose
    /// Gets stored line boundaries for cursor movement logic.
    ///
    /// # Arguments
    /// * `row` - Display row index (0-indexed)
    ///
    /// # Returns
    /// * `Ok(Some((start, end)))` - Line exists with these byte bounds
    /// * `Ok(None)` - Row not yet populated (empty window area)
    /// * `Err(io::Error)` - Row index out of bounds
    ///
    /// # Defensive Notes
    /// Returns error for invalid row, not silent None.
    /// Caller must distinguish between "row not populated" (Ok(None))
    /// and "invalid row index" (Err).
    pub fn get_line_byte_range(&self, row: usize) -> io::Result<Option<(u64, u64)>> {
        // Defensive: Validate row index
        if row >= MAX_TUI_ROWS {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!("Row {} exceeds maximum display rows {}", row, MAX_TUI_ROWS),
            ));
        }

        Ok(self.line_byte_start_end_position_pairs[row])
    }

    /// Checks if a file byte position is at the start of its line
    ///
    /// # Purpose
    /// Detects when cursor moves to line start for wrap-around behavior.
    /// When user presses 'h' (move left) at start of line,
    /// cursor should wrap to end of previous line.
    ///
    /// # Arguments
    /// * `row` - Current display row (0-indexed)
    /// * `byte_position` - File byte offset to check
    ///
    /// # Returns
    /// * `Ok(true)` - Byte is at start of this line
    /// * `Ok(false)` - Byte is NOT at line start (is middle or end)
    /// * `Err(io::Error)` - Row index invalid or range not set
    ///
    /// # Logic
    /// Checks if byte_position == line_start_byte of the row's range.
    ///
    /// # Example
    /// ```ignore
    /// // Line "hello\n" stored as (10, 15)
    /// is_at_line_start(0, 10)?  // true - at start
    /// is_at_line_start(0, 12)?  // false - in middle
    /// is_at_line_start(0, 15)?  // false - at end
    /// ```
    pub fn is_at_line_start(&self, row: usize, byte_position: u64) -> io::Result<bool> {
        // Get line boundaries (defensive: propagate error if row invalid)
        match self.get_line_byte_range(row)? {
            Some((start_byte, _end_byte)) => {
                // Compare byte position to line start
                Ok(byte_position == start_byte)
            }
            None => {
                // Row not populated - can't determine line start
                // Return false (not at line start of non-existent line)
                Ok(false)
            }
        }
    }

    /// Checks if a file byte position is at the end of its line
    ///
    /// # Purpose
    /// Detects when cursor moves to line end for wrap-around behavior.
    /// When user presses 'l' (move right) at end of line,
    /// cursor should wrap to start of next line.
    ///
    /// # Arguments
    /// * `row` - Current display row (0-indexed)
    /// * `byte_position` - File byte offset to check
    ///
    /// # Returns
    /// * `Ok(true)` - Byte is at end of this line (last content byte before newline)
    /// * `Ok(false)` - Byte is NOT at line end (is start or middle)
    /// * `Err(io::Error)` - Row index invalid or range not set
    ///
    /// # Logic
    /// Checks if byte_position == line_end_byte of the row's range.
    /// Note: end_byte is BEFORE the newline character, so cursor can be positioned there.
    ///
    /// # Empty Lines
    /// For empty line (start == end):
    /// - Position equals both start and end
    /// - Both `is_at_line_start()` and `is_at_line_end()` return true
    /// - Caller must handle this ambiguity (usually treated as both start and end)
    ///
    /// # Example
    /// ```ignore
    /// // Line "hello\n" stored as (10, 15)
    /// is_at_line_end(0, 10)?  // false - at start
    /// is_at_line_end(0, 12)?  // false - in middle
    /// is_at_line_end(0, 15)?  // true - at end
    ///
    /// // Empty line "\n" stored as (20, 20)
    /// is_at_line_end(1, 20)?  // true - at end (also at start)
    /// ```
    pub fn is_at_line_end(&self, row: usize, byte_position: u64) -> io::Result<bool> {
        // Get line boundaries (defensive: propagate error if row invalid)
        match self.get_line_byte_range(row)? {
            Some((_start_byte, end_byte)) => {
                // Compare byte position to line end
                Ok(byte_position == end_byte)
            }
            None => {
                // Row not populated - can't determine line end
                // Return false (not at line end of non-existent line)
                Ok(false)
            }
        }
    }

    /// Clears all line byte range tracking
    ///
    /// # Purpose
    /// Resets line boundary data when rebuilding window (e.g., after scroll).
    /// Called at start of `build_windowmap_nowrap()`.
    pub fn clear_line_byte_ranges(&mut self) {
        // Defensive: explicit loop with bounds (NASA Power of 10 Rule 2)
        for row in 0..MAX_TUI_ROWS {
            self.line_byte_start_end_position_pairs[row] = None;
        }
    }
}


windomap


    /// Retrieves the byte range for a display row
    ///
    /// # Purpose
    /// Gets stored line boundaries for cursor movement logic.
    ///
    /// # Arguments
    /// * `row` - Display row index (0-indexed)
    ///
    /// # Returns
    /// * `Ok(Some((start, end)))` - Line exists with these byte bounds
    /// * `Ok(None)` - Row not yet populated (empty window area)
    /// * `Err(io::Error)` - Row index out of bounds
    ///
    /// # Defensive Notes
    /// Returns error for invalid row, not silent None.
    /// Caller must distinguish between "row not populated" (Ok(None))
    /// and "invalid row index" (Err).
    pub fn get_line_byte_range(&self, row: usize) -> io::Result<Option<(u64, u64)>> {
        // Defensive: Validate row index
        if row >= MAX_TUI_ROWS {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!("Row {} exceeds maximum display rows {}", row, MAX_TUI_ROWS),
            ));
        }

        Ok(self.line_byte_start_end_position_pairs[row])
    }

    /// Checks if a file byte position is at the start of its line
    ///
    /// # Purpose
    /// Detects when cursor moves to line start for wrap-around behavior.
    /// When user presses 'h' (move left) at start of line,
    /// cursor should wrap to end of previous line.
    ///
    /// # Arguments
    /// * `row` - Current display row (0-indexed)
    /// * `byte_position` - File byte offset to check
    ///
    /// # Returns
    /// * `Ok(true)` - Byte is at start of this line
    /// * `Ok(false)` - Byte is NOT at line start (is middle or end)
    /// * `Err(io::Error)` - Row index invalid or range not set
    ///
    /// # Logic
    /// Checks if byte_position == line_start_byte of the row's range.
    ///
    /// # Example
    /// ```ignore
    /// // Line "hello\n" stored as (10, 15)
    /// is_at_line_start(0, 10)?  // true - at start
    /// is_at_line_start(0, 12)?  // false - in middle
    /// is_at_line_start(0, 15)?  // false - at end
    /// ```
    pub fn is_at_line_start(&self, row: usize, byte_position: u64) -> io::Result<bool> {
        // Get line boundaries (defensive: propagate error if row invalid)
        match self.get_line_byte_range(row)? {
            Some((start_byte, _end_byte)) => {
                // Compare byte position to line start
                Ok(byte_position == start_byte)
            }
            None => {
                // Row not populated - can't determine line start
                // Return false (not at line start of non-existent line)
                Ok(false)
            }
        }
    }

    /// Checks if a file byte position is at the end of its line
    ///
    /// # Purpose
    /// Detects when cursor moves to line end for wrap-around behavior.
    /// When user presses 'l' (move right) at end of line,
    /// cursor should wrap to start of next line.
    ///
    /// # Arguments
    /// * `row` - Current display row (0-indexed)
    /// * `byte_position` - File byte offset to check
    ///
    /// # Returns
    /// * `Ok(true)` - Byte is at end of this line (last content byte before newline)
    /// * `Ok(false)` - Byte is NOT at line end (is start or middle)
    /// * `Err(io::Error)` - Row index invalid or range not set
    ///
    /// # Logic
    /// Checks if byte_position == line_end_byte of the row's range.
    /// Note: end_byte is BEFORE the newline character, so cursor can be positioned there.
    ///
    /// # Empty Lines
    /// For empty line (start == end):
    /// - Position equals both start and end
    /// - Both `is_at_line_start()` and `is_at_line_end()` return true
    /// - Caller must handle this ambiguity (usually treated as both start and end)
    ///
    /// # Example
    /// ```ignore
    /// // Line "hello\n" stored as (10, 15)
    /// is_at_line_end(0, 10)?  // false - at start
    /// is_at_line_end(0, 12)?  // false - in middle
    /// is_at_line_end(0, 15)?  // true - at end
    ///
    /// // Empty line "\n" stored as (20, 20)
    /// is_at_line_end(1, 20)?  // true - at end (also at start)
    /// ```
    pub fn is_at_line_end(&self, row: usize, byte_position: u64) -> io::Result<bool> {
        // Get line boundaries (defensive: propagate error if row invalid)
        match self.get_line_byte_range(row)? {
            Some((_start_byte, end_byte)) => {
                // Compare byte position to line end
                Ok(byte_position == end_byte)
            }
            None => {
                // Row not populated - can't determine line end
                // Return false (not at line end of non-existent line)
                Ok(false)
            }
        }
    }

// // KEEP THIS
// /// Deletes single byte at specific file position
// ///
// /// # Overview
// ///
// /// This helper function removes one byte from a file by shifting all subsequent
// /// bytes left by one position, then truncating the file to new length.
// ///
// /// **Operation:**
// /// ```text
// /// Before: [A B C D E F]
// ///         Delete byte at position 3
// /// After:  [A B C E F]
// ///                 ↑ D removed, E shifted left
// /// ```
// ///
// /// # Memory Safety - Stack Allocated Buffer
// ///
// /// Uses 8KB stack buffer for shifting bytes after deletion point.
// /// - No heap allocation for data processing
// /// - Fixed-size buffer regardless of file size
// /// - If file has > 8KB after deletion point, shifts occur in 8KB chunks
// ///
// /// # Arguments
// ///
// /// * `file_path` - Path to target file (read+write access required)
// /// * `position` - Byte offset to delete (0 = first byte, file_size-1 = last byte)
// ///
// /// # Returns
// ///
// /// * `Ok(())` - Byte deleted successfully, file shortened by 1 byte
// /// * `Err(io::Error)` - File operation failed (open, seek, read, write, truncate, flush)
// ///
// /// # Algorithm
// ///
// /// 1. Open file in read+write mode
// /// 2. Seek to position+1 (first byte to keep)
// /// 3. Read bytes after deletion point into buffer (up to 8KB)
// /// 4. Seek back to deletion position
// /// 5. Write shifted bytes (from buffer)
// /// 6. Truncate file to new length (original - 1 byte)
// /// 7. Flush to ensure data written to disk
// ///
// /// # Edge Cases
// ///
// /// **Delete last byte (position == file_size - 1):**
// /// - Read after position+1 returns 0 bytes
// /// - Nothing to shift
// /// - File truncated by 1 byte
// /// - Most efficient case
// ///
// /// **Delete first byte (position == 0):**
// /// - Reads entire file into buffer (up to 8KB)
// /// - Writes at position 0 (original position 1 bytes)
// /// - All bytes shifted left
// /// - Most expensive case
// ///
// /// **Delete with > 8KB after deletion point:**
// /// - Only first 8KB shifted
// /// - **BUG:** Bytes beyond 8KB not shifted, file corrupted
// /// - Should loop-shift in chunks
// /// - Current implementation assumes remaining bytes < 8KB
// ///
// /// **Delete beyond EOF (position >= file_size):**
// /// - Read returns 0 bytes
// /// - Write does nothing
// /// - Truncate sets file size to position (might grow file!)
// /// - Unexpected behavior - should validate position < file_size
// ///
// /// **Empty file (file_size == 0):**
// /// - Any position is invalid
// /// - Read returns 0 bytes
// /// - Truncate sets size to position (creates zero-byte file)
// /// - Should error if file empty
// ///
// /// # Defensive Programming
// ///
// /// - No unwrap calls
// /// - All I/O operations explicitly error-checked
// /// - Truncate ensures file size reflects deletion
// /// - Flush called to ensure disk write
// ///
// /// # Performance
// ///
// /// - **Time:** O(M) where M = bytes after deletion point (up to 8KB)
// /// - **Space:** O(1) - fixed 8KB stack buffer
// /// - **I/O:** 1 read, 2 seeks, 1 write, 1 truncate, 1 flush = 6 operations
// /// - Not optimized for repeated deletions (each call shifts independently)
// ///
// /// # Known Limitations
// ///
// /// **8KB shift buffer limit:**
// /// If file has > 8KB bytes after deletion point:
// /// - Only first 8KB shifted correctly
// /// - Data beyond 8KB lost
// /// - Should loop to shift all remaining bytes
// ///
// /// **No validation:**
// /// Doesn't check if position is valid (< file_size)
// /// Invalid position causes undefined behavior
// ///
// /// **No atomic operation:**
// /// If write or truncate fails mid-operation, file left inconsistent.
// /// No rollback mechanism.
// ///
// /// # See Also
// ///
// /// * `insert_bytes_at_position()` - Inverse operation (adds bytes)
// /// * `insert_file_at_cursor()` - Caller that uses this for final byte removal
// fn delete_byte_at_position(file_path: &Path, position: u64) -> io::Result<()> {
//     // Open file for read+write
//     // Requires file already exists
//     let mut file = OpenOptions::new().read(true).write(true).open(file_path)?;

//     // Pre-allocated buffer for bytes after deletion point
//     // 8KB chosen as balance between stack usage and shift efficiency
//     const BUFFER_SIZE: usize = 8192;
//     let mut after_buffer = [0u8; BUFFER_SIZE];

//     // Seek to position+1 (skip the byte being deleted)
//     // Read bytes that need to be shifted left
//     file.seek(SeekFrom::Start(position + 1))?;
//     let bytes_after = file.read(&mut after_buffer)?;

//     // Seek back to deletion position
//     // Write the shifted bytes starting at deletion position
//     file.seek(SeekFrom::Start(position))?;
//     file.write_all(&after_buffer[..bytes_after])?;

//     // Truncate file to new length (original size - 1 byte)
//     // This removes the duplicate byte at end that resulted from shift-left
//     let new_length = position + bytes_after as u64;
//     file.set_len(new_length)?;

//     // Flush to ensure data written to disk
//     file.flush()?;

//     Ok(())
// }

    // /// Checks if cursor is at the end of its current line
    // ///
    // /// # Purpose
    // /// Uses cursor position already in state to determine line end.
    // /// Used for move-right wrapping: when user presses 'l' at line end,
    // /// cursor wraps to start of next line.
    // ///
    // /// # Returns
    // /// * `Ok(true)` - Cursor is at the last byte of current line
    // /// * `Ok(false)` - Cursor is NOT at line end
    // /// * `Err(LinesError)` - Cannot determine (state error or invalid position)
    // ///
    // /// # Defensive
    // /// All lookups must succeed - returns error if data missing or invalid
    // pub fn is_cursor_at_line_end(&self) -> Result<bool> {
    //     // Get line byte range for current row
    //     let (_start_byte, end_byte) = self.window_map.line_byte_start_end_position_pairs
    //         [self.cursor.row]
    //         .ok_or_else(|| {
    //             let msg = format!("Line byte range not set for row {}", self.cursor.row);
    //             log_error(&msg, Some("is_cursor_at_line_end"));
    //             LinesError::StateError(msg)
    //         })?;

    //     // Get cursor's file byte position
    //     let cursor_byte_offset = self
    //         .window_map
    //         .get_row_col_file_position(self.cursor.row, self.cursor.col)?
    //         .ok_or_else(|| {
    //             let msg = format!(
    //                 "Cursor at ({}, {}) maps to empty cell",
    //                 self.cursor.row, self.cursor.col
    //             );
    //             log_error(&msg, Some("is_cursor_at_line_end"));
    //             LinesError::StateError(msg)
    //         })?
    //         .byte_offset_linear_file_absolute_position;

    //     // Defensive: cursor should never exceed line end
    //     if cursor_byte_offset > end_byte {
    //         let msg = format!(
    //             "Cursor byte {} exceeds line end {} (row {}, col {})",
    //             cursor_byte_offset, end_byte, self.cursor.row, self.cursor.col
    //         );
    //         log_error(&msg, Some("is_cursor_at_line_end"));
    //         return Err(LinesError::StateError(msg));
    //     }

    //     Ok(cursor_byte_offset == end_byte)
    // }

    /// Checks if cursor is at the start of its current line
    ///
    /// # Purpose
    /// Uses cursor position already in state to determine line start.
    /// Used for move-left wrapping: when user presses 'h' at line start,
    /// cursor wraps to end of previous line.
    ///
    /// # Returns
    /// * `Ok(true)` - Cursor is at the first byte of current line
    /// * `Ok(false)` - Cursor is NOT at line start
    /// * `Err(LinesError)` - Cannot determine (state error or invalid position)
    ///
    /// # Defensive
    /// All lookups must succeed - returns error if data missing or invalid
    pub fn is_cursor_at_line_start(&self) -> Result<bool> {
        // Get line byte range for current row
        let (start_byte, _end_byte) = self.window_map.line_byte_start_end_position_pairs
            [self.cursor.row]
            .ok_or_else(|| {
                let msg = format!("Line byte range not set for row {}", self.cursor.row);
                log_error(&msg, Some("is_cursor_at_line_start"));
                LinesError::StateError(msg)
            })?;

        // Get cursor's file byte position
        let cursor_byte_offset = self
            .window_map
            .get_row_col_file_position(self.cursor.row, self.cursor.col)?
            .ok_or_else(|| {
                let msg = format!(
                    "Cursor at ({}, {}) maps to empty cell",
                    self.cursor.row, self.cursor.col
                );
                log_error(&msg, Some("is_cursor_at_line_start"));
                LinesError::StateError(msg)
            })?
            .byte_offset_linear_file_absolute_position;

        // Defensive: cursor should never be before line start
        if cursor_byte_offset < start_byte {
            let msg = format!(
                "Cursor byte {} is before line start {} (row {}, col {})",
                cursor_byte_offset, start_byte, self.cursor.row, self.cursor.col
            );
            log_error(&msg, Some("is_cursor_at_line_start"));
            return Err(LinesError::StateError(msg));
        }

        Ok(cursor_byte_offset == start_byte)
    }

}

    #[test]
    fn test_calculate_display_width() {
        assert_eq!(calculate_display_width("Hello"), Some(5));
        assert_eq!(calculate_display_width("你好"), Some(4));
        assert_eq!(calculate_display_width("Hello世界"), Some(9));
        assert_eq!(calculate_display_width(""), Some(0));
        assert_eq!(calculate_display_width("ＡＢＣ"), Some(6));
    }

    #[test]
    fn test_mixed_width_string() {
        let mixed = "Hello 世界 World";
        let expected = 5 + 1 + 2 + 2 + 1 + 5; // "Hello" + " " + "世界" + " " + "World"
        assert_eq!(calculate_display_width(mixed), Some(expected));
    }
        let display_width =
            double_width::calculate_display_width(content).expect("Should calculate width");
        assert_eq!(display_width, 10, "Should be 10 display columns total");

        // Display width should fit within terminal
        let row_display_width = double_width::calculate_display_width(first_row_str)
            .expect("Should calculate display width");
        assert!(
            row_display_width <= 80,
            "Display width {} should not exceed terminal width 80",
            row_display_width
        );

    // /// Checks if a file byte position is at the end of its line
    // ///
    // /// # Purpose
    // /// Detects when cursor moves to line end for wrap-around behavior.
    // /// When user presses 'l' (move right) at end of line,
    // /// cursor should wrap to start of next line.
    // ///
    // /// # Arguments
    // /// * `row` - Current display row (0-indexed)
    // /// * `byte_position` - File byte offset to check
    // ///
    // /// # Returns
    // /// * `Ok(true)` - Byte is at end of this line (last content byte before newline)
    // /// * `Ok(false)` - Byte is NOT at line end (is start or middle)
    // /// * `Err(io::Error)` - Row index invalid or range not set
    // ///
    // /// # Logic
    // /// Checks if byte_position == line_end_byte of the row's range.
    // /// Note: end_byte is BEFORE the newline character, so cursor can be positioned there.
    // ///
    // /// # Empty Lines
    // /// For empty line (start == end):
    // /// - Position equals both start and end
    // /// - Both `is_at_line_start()` and `is_at_line_end()` return true
    // /// - Caller must handle this ambiguity (usually treated as both start and end)
    // ///
    // /// # Example
    // /// ```ignore
    // /// // Line "hello\n" stored as (10, 15)
    // /// is_at_line_end(0, 10)?  // false - at start
    // /// is_at_line_end(0, 12)?  // false - in middle
    // /// is_at_line_end(0, 15)?  // true - at end
    // ///
    // /// // Empty line "\n" stored as (20, 20)
    // /// is_at_line_end(1, 20)?  // true - at end (also at start)
    // /// ```
    // pub fn is_at_line_end(&self, row: usize, byte_position: u64) -> io::Result<bool> {
    //     // Get line boundaries (defensive: propagate error if row invalid)
    //     match self.get_line_byte_range(row)? {
    //         Some((_start_byte, end_byte)) => {
    //             // Compare byte position to line end
    //             Ok(byte_position == end_byte)
    //         }
    //         None => {
    //             // Row not populated - can't determine line end
    //             // Return false (not at line end of non-existent line)
    //             Ok(false)
    //         }
    //     }
    // }


works but does not check for existing time-match file
// /// Creates a read-only copy of the file in the session directory
// ///
// /// # Purpose
// /// Creates a timestamped copy in the session directory that won't be modified
// /// during editing. This prevents corruption if the editor crashes while writing.
// /// Read-copies are VISIBLE (no hidden files) and located in session directory
// /// for easy access and crash recovery.
// ///
// /// # Arguments
// /// * `original_path` - Path to the original file
// /// * `session_dir` - Path to this session's directory (from EditorState)
// ///
// /// # Returns
// /// * `Ok(PathBuf)` - Path to the read-copy in session directory
// /// * `Err(io::Error)` - Copy operation failed
// ///
// /// # File Naming
// /// Original: `/path/to/file.txt`
// /// Session dir: `{executable_dir}/lines_data/sessions/2025_01_15_14_30_45/`
// /// Read-copy: `{session_dir}/2025_01_15_14_30_45_file.txt`
// ///
// /// # Design Notes
// /// - NO hidden files (no leading dot) - files should be visible to user
// /// - Stored in session directory for crash recovery
// /// - Timestamp prefix ensures uniqueness
// /// - Session directory persists after exit for recovery
// pub fn create_a_readcopy_of_file(
//     original_path: &Path,
//     session_dir: &Path,
//     session_time_stamp: String,
// ) -> io::Result<PathBuf> {
//     // Defensive: Validate inputs
//     if !original_path.exists() {
//         return Err(io::Error::new(
//             io::ErrorKind::NotFound,
//             "Original file does not exist",
//         ));
//     }

//     if !session_dir.exists() || !session_dir.is_dir() {
//         return Err(io::Error::new(
//             io::ErrorKind::NotFound,
//             "Session directory does not exist",
//         ));
//     }

//     // Get original filename
//     let file_name = original_path
//         .file_name()
//         .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidInput, "Cannot determine filename"))?
//         .to_string_lossy();

//     // Build read-copy filename: {timestamp}_{original_filename}
//     // NO leading dot - file should be visible

//     // let read_copy_name = format!("{}_{}", session_time_stamp, file_name);
//     // let read_copy_path = session_dir.join(&read_copy_name);
//     let st_formatted_read_copy_path =
//         stack_format_it("{}_{}", &[&session_time_stamp, &file_name], "N_N");
//     let read_copy_path = session_dir.join(&st_formatted_read_copy_path);

//     // If read-copy already exists, return it immediately (idempotent)
//     if read_copy_path.exists() {
//         return Ok(read_copy_path);
//     }

//     // Copy the file to session directory
//     fs::copy(original_path, &read_copy_path).map_err(|e| {
//         io::Error::new(
//             io::ErrorKind::Other,
//             format!("Failed to create read-copy: {}", e),
//         )
//     })?;

//     // Defensive: Verify copy succeeded
//     if !read_copy_path.exists() {
//         return Err(io::Error::new(
//             io::ErrorKind::Other,
//             "Read-copy creation reported success but file not found",
//         ));
//     }

//     // // Diagnostic Log success for user visibility
//     // println!("Read-copy created: {}", read_copy_path.display());

//     // Assertion: Verify result is valid
//     debug_assert!(
//         read_copy_path.is_absolute(),
//         "Read-copy path should be absolute"
//     );
//     debug_assert!(
//         read_copy_path.exists(),
//         "Read-copy should exist after creation"
//     );

//     Ok(read_copy_path)
// }

/// Formats a message with multiple variable parts inserted at {} placeholders.
///
/// ## Project Context
/// Provides simple string formatting for UI messages and error messages using
/// stack-allocated buffers. Designed for display text where formatting failure
/// can gracefully degrade to a fallback message without compromising program
/// operation.
///
/// **Use for:**
/// - Status bar updates
/// - User notifications
/// - Progress indicators
/// - Display-only error messages
///
/// **Do NOT use for:**
/// - output that may exceed a known size
/// - where a known default is less optimal than erroring-out
///
/// Stack allocation makes this function safer and more predictable than
/// heap-based formatting for bounded display messages.
///
/// ## Operation
/// Takes a template string with one or more "{}" placeholders and inserts variable
/// strings in order. Processes each placeholder sequentially, replacing with the
/// corresponding insert string.
///
/// Examples:
/// - stack_format_it("inserted {} bytes", &["42"]) -> "inserted 42 bytes"
/// - stack_format_it("range: start={} > end={}", &["10", "5"]) -> "range: start=10 > end=5"
/// - stack_format_it("a {} b {} c {}", &["1", "2", "3"]) -> "a 1 b 2 c 3"
///
/// ## Safety & Error Handling
/// - No panic: Always returns a valid string (formatted or fallback)
/// - No unwrap: Direct return, no Result to unwrap
/// - Uses 256-byte stack buffer for formatting
/// - Returns fallback if result exceeds buffer size
/// - Returns fallback if placeholder count doesn't match insert count
/// - Returns fallback if template has no {} placeholders
/// - Maximum 8 inserts supported (configurable via MAX_INSERTS)
///
/// ## Parameters
/// - `template`: String with one or more "{}" placeholders
/// - `inserts`: Slice of strings to insert at placeholders (in order)
/// - `fallback`: Message to return if formatting fails
///
/// ## Returns
/// Formatted string on success, fallback string on any error (always valid)
///
/// ## Use Examples:
/// ```rust
/// let bytes = total_bytes_written.saturating_sub(1);
/// let num_str = bytes.to_string();
/// let message = stack_format_it("inserted {} bytes", &[&num_str], "inserted data");
/// ```
///
/// Error Formatting:
/// ```
/// io::stdout().flush().map_err(|e| {
///     LinesError::DisplayError(stack_format_it(
///         "Failed to flush stdout: {}",
///         &[&e.to_string()],
///         "Failed to flush stdout",
///     ))
/// })?;
/// ```
///
/// ```rust
/// let num_1 = start_byte.to_string();
/// let num_2 = end_byte.to_string();
/// let formatted_string = stack_format_it(
///     "Invalid byte range: start={} > end={}",
///     &[&num_1, &num_2],
///     "Invalid byte range"
/// );
/// ```
fn stack_format_it1(template: &str, inserts: &[&str], fallback: &str) -> String {
    // Internal stack buffer for result
    let mut buf = [0u8; 256];

    // Maximum number of inserts to prevent abuse
    const MAX_INSERTS: usize = 128;

    // Check insert count
    if inserts.is_empty() {
        #[cfg(debug_assertions)]
        eprintln!("stack_format_it: No inserts provided");
        return fallback.to_string();
    }

    if inserts.len() > MAX_INSERTS {
        #[cfg(debug_assertions)]
        eprintln!("stack_format_it: Too many inserts (max {})", MAX_INSERTS);
        return fallback.to_string();
    }

    // Count placeholders in template
    let placeholder = "{}";
    let placeholder_count = template.matches(placeholder).count();

    if placeholder_count == 0 {
        #[cfg(debug_assertions)]
        eprintln!("stack_format_it: No '{{}}' placeholders found in template");
        return fallback.to_string();
    }

    if placeholder_count != inserts.len() {
        #[cfg(debug_assertions)]
        eprintln!(
            "stack_format_it: Placeholder count ({}) doesn't match insert count ({})",
            placeholder_count,
            inserts.len()
        );
        return fallback.to_string();
    }

    // Calculate total length needed
    let mut total_len = template.len();

    // Subtract placeholder lengths
    total_len = match total_len.checked_sub(placeholder.len() * placeholder_count) {
        Some(len) => len,
        None => {
            #[cfg(debug_assertions)]
            eprintln!("stack_format_it: Length calculation underflow");
            return fallback.to_string();
        }
    };

    // Add insert lengths
    for insert in inserts {
        total_len = match total_len.checked_add(insert.len()) {
            Some(len) => len,
            None => {
                #[cfg(debug_assertions)]
                eprintln!("stack_format_it: Length overflow");
                return fallback.to_string();
            }
        };
    }

    // Check buffer capacity
    if total_len > buf.len() {
        #[cfg(debug_assertions)]
        eprintln!(
            "stack_format_it: Result too large (need {}, have {})",
            total_len,
            buf.len()
        );
        return fallback.to_string();
    }

    // Build the result by processing each placeholder
    let mut pos = 0;
    let mut remaining_template = template;
    let mut insert_idx = 0;

    while let Some(placeholder_pos) = remaining_template.find(placeholder) {
        // Copy text before placeholder
        let before = &remaining_template[..placeholder_pos];
        if pos + before.len() > buf.len() {
            #[cfg(debug_assertions)]
            eprintln!("stack_format_it: Buffer overflow during copy");
            return fallback.to_string();
        }
        buf[pos..pos + before.len()].copy_from_slice(before.as_bytes());
        pos += before.len();

        // Copy insert
        let insert = inserts[insert_idx];
        if pos + insert.len() > buf.len() {
            #[cfg(debug_assertions)]
            eprintln!("stack_format_it: Buffer overflow during insert");
            return fallback.to_string();
        }
        buf[pos..pos + insert.len()].copy_from_slice(insert.as_bytes());
        pos += insert.len();

        // Move to next segment
        remaining_template = &remaining_template[placeholder_pos + placeholder.len()..];
        insert_idx += 1;
    }

    // Copy remaining text after last placeholder
    if pos + remaining_template.len() > buf.len() {
        #[cfg(debug_assertions)]
        eprintln!("stack_format_it: Buffer overflow during final copy");
        return fallback.to_string();
    }
    buf[pos..pos + remaining_template.len()].copy_from_slice(remaining_template.as_bytes());
    pos += remaining_template.len();

    // Validate UTF-8 and return
    match std::str::from_utf8(&buf[..pos]) {
        Ok(s) => s.to_string(),
        Err(_) => {
            #[cfg(debug_assertions)]
            eprintln!("stack_format_it: Invalid UTF-8 in result");
            fallback.to_string()
        }
    }
}
