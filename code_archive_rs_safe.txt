// useful
    // Add .txt extension if no extension provided
    let mut buf = [0u8; 8]; // Adjust size as needed
    let filename_bytes;

    let filename = if trimmed.contains('.') {
        trimmed
    } else {
        let txt_suffix = b".txt";
        let trimmed_bytes = trimmed.as_bytes();

        if trimmed_bytes.len() + txt_suffix.len() <= buf.len() {
            buf[..trimmed_bytes.len()].copy_from_slice(trimmed_bytes);
            buf[trimmed_bytes.len()..trimmed_bytes.len() + txt_suffix.len()]
                .copy_from_slice(txt_suffix);

            filename_bytes = &buf[..trimmed_bytes.len() + txt_suffix.len()];
            std::str::from_utf8(filename_bytes).unwrap()
        } else {
            trimmed // Fallback if name too long
        }
    };

    Ok(filename.to_string())

to use:
                #[cfg(debug_assertions)]
                eprintln!("e: {}", e);


/// Converts byte to raw string representation with escape sequences
///
/// # Arguments
/// * `byte` - Single byte to convert
///
/// # Returns
/// String representation (1-4 characters):
/// - Regular printable ASCII → single character
/// - Special chars → escape sequence (\n, \t, etc.)
/// - Non-printable → hex escape (\xHH)
///
/// # Examples
/// ```
/// byte_to_raw_escape(0x0A) // "\n"
/// byte_to_raw_escape(0x48) // "H"
/// byte_to_raw_escape(0x00) // "\x00"
/// ```
fn byte_to_raw_escape(byte: u8) -> String {
    match byte {
        0x0A => "\\n".to_string(),  // Newline
        0x09 => "\\t".to_string(),  // Tab
        0x0D => "\\r".to_string(),  // Carriage return
        0x5C => "\\\\".to_string(), // Backslash
        0x22 => "\\\"".to_string(), // Quote
        0x00 => "\\0".to_string(),  // Null
        0x20..=0x7E => {
            // Printable ASCII (space through ~)
            if byte == 0x5C || byte == 0x22 {
                // Already handled above
                format!("{}", byte as char)
            } else {
                format!("{}", byte as char)
            }
        }
        _ => {
            // Non-printable → hex escape
            format!("\\x{:02X}", byte)
        }
    }
}


/// Creates a timestamp string with full year prefix for archive file naming
///
/// # Purpose
/// Generates a consistent, sortable timestamp string for archive filenames
/// that works identically across all platforms (Windows, Linux, macOS).
/// Includes full 4-digit year prefix for better year identification.
///
/// # Arguments
/// * `time` - The SystemTime to format (typically SystemTime::now())
///
/// # Returns
/// * `String` - Timestamp in format: "YYYY_YY_MM_DD_HH_MM_SS"
///
/// # Format Specification
/// - YYYY: Four-digit year (0000-9999)
/// - YY: Two-digit year (00-99)
/// - MM: Two-digit month (01-12)
/// - DD: Two-digit day (01-31)
/// - HH: Two-digit hour in 24-hour format (00-23)
/// - MM: Two-digit minute (00-59)
/// - SS: Two-digit second (00-59)
///
/// # Examples
/// - "2024_24_01_15_14_30_45" for January 15, 2024 at 2:30:45 PM
/// - "2023_23_12_31_23_59_59" for December 31, 2023 at 11:59:59 PM
///
/// # Platform Consistency
/// This function produces identical output on all platforms by using
/// epoch-based calculations rather than platform-specific date commands.
fn create_archive_timestamp(time: SystemTime) -> String {
    // Get duration since Unix epoch
    let duration_since_epoch = match time.duration_since(UNIX_EPOCH) {
        Ok(duration) => duration,
        Err(_) => {
            // System time before Unix epoch - use fallback
            eprintln!("Warning: System time is before Unix epoch, using fallback timestamp");
            return String::from("1970_70_01_01_00_00_00");
        }
    };

    let total_seconds = duration_since_epoch.as_secs();

    // Use the accurate date calculation
    let (year, month, day, hour, minute, second) =
        epoch_seconds_to_datetime_components(total_seconds);

    // Assertion 1: Validate year range
    const MAX_REASONABLE_YEAR: u32 = 9999;
    if year > MAX_REASONABLE_YEAR {
        eprintln!(
            "Warning: Year {} exceeds maximum reasonable value {}. Using fallback.",
            year, MAX_REASONABLE_YEAR
        );
        return String::from("9999_99_12_31_23_59_59");
    }

    // Assertion 2: Validate all components are in expected ranges
    if month < 1 || month > 12 || day < 1 || day > 31 || hour > 23 || minute > 59 || second > 59 {
        eprintln!(
            "Warning: Invalid date/time components: {}-{:02}-{:02} {:02}:{:02}:{:02}",
            year, month, day, hour, minute, second
        );
        return String::from("1970_70_01_01_00_00_00"); // Safe fallback
    }

    // Format as YYYY_YY_MM_DD_HH_MM_SS
    format!(
        "{:04}_{:02}_{:02}_{:02}_{:02}_{:02}_{:02}",
        year,       // Four-digit year
        year % 100, // Two-digit year
        month,
        day,
        hour,
        minute,
        second
    )
}

/// Moves cursor to position BEFORE next syntax character (Vim-style 'e' command)
///
/// # Purpose
/// Implements 'e' command for word navigation. Moves cursor forward to the
/// position BEFORE the next syntax character. This positions cursor at the
/// last non-syntax character of current word.
/// Also counts newlines to allow window scrolling without rebuild.
///
/// # Algorithm
/// 1. Move forward 2 bytes (assumption: next byte is syntax, skip it)
/// 2. Loop (max 64 iterations):
///    - Peek ahead 1 byte (look at next position)
///    - If next byte is syntax OR EOF → STOP (cursor is positioned)
///    - If next byte is non-syntax → move cursor forward 1 byte, continue
///    - If newline encountered during move: increment counter
/// 3. Return final byte offset AND newline count
///
/// # Arguments
/// * `file_path` - Absolute path to file being edited
/// * `current_byte_offset` - Current cursor position (0-indexed byte offset)
/// * `file_size` - Total file size in bytes (for EOF detection)
///
/// # Returns
/// * `Ok((new_byte_offset, newlines_crossed))` where:
///   - `new_byte_offset` - Position before next syntax char (or EOF)
///   - `newlines_crossed` - Number of 0x0A bytes encountered during move
/// * `Err(LinesError)` - File read error
///
/// # Edge Cases
/// - Cursor at EOF: returns `(EOF_pos, 0)` (no movement possible)
/// - Cursor already before syntax: moves past it to next word end
/// - Multiple syntax chars in row: skips first, stops at next
/// - Crosses newline: counts it, positions before next syntax
/// - File with no syntax: moves 64+ bytes forward (iteration limit)
///
/// # Memory Safety
/// - Stack-only: 1-byte read buffer
/// - No dynamic allocation
/// - Bounded iterations (max 64)
///
/// # Defensive Programming
/// - Iteration limit prevents infinite loops (NASA Rule #2)
/// - All read errors propagated
/// - Saturating arithmetic prevents underflow/overflow
/// - Peek-ahead safely handles EOF (no buffer overflow)
/// - Byte-level syntax check safe for UTF-8
///
/// # Example
/// ```ignore
/// // File: "hello world"
/// // Cursor at byte 0 (on 'h')
/// let (new_pos, newlines) = move_word_end(path, 0, 11)?;
/// // Moves forward 2 (to 'l'), then peeks at 'l' (non-syntax)
/// // Continues moving: 'l'->'o'->space (stop before space)
/// // Returns (4, 0) - positioned on 'o'
/// ```
pub fn move_word_end(
    file_path: &Path,
    current_byte_offset: u64,
    file_size: u64,
) -> Result<(u64, usize)> {
    // Returns: (new_byte_offset, newlines_crossed)

    // =========================================================================
    // INPUT VALIDATION
    // =========================================================================

    // Debug assert: path should be valid
    debug_assert!(
        !file_path.as_os_str().is_empty(),
        "File path cannot be empty"
    );

    // Test assert: path should be valid
    #[cfg(test)]
    assert!(
        !file_path.as_os_str().is_empty(),
        "File path cannot be empty"
    );

    // Production check: path empty
    if file_path.as_os_str().is_empty() {
        return Err(LinesError::InvalidInput("File path cannot be empty".into()));
    }

    // Debug assert: offset should not exceed file size
    debug_assert!(
        current_byte_offset <= file_size,
        "Cursor offset {} exceeds file size {}",
        current_byte_offset,
        file_size
    );

    // Test assert: offset should not exceed file size
    #[cfg(test)]
    assert!(
        current_byte_offset <= file_size,
        "Cursor offset {} exceeds file size {}",
        current_byte_offset,
        file_size
    );

    // Production check: offset exceeds file size
    if current_byte_offset > file_size {
        return Err(LinesError::InvalidInput(format!(
            "Cursor offset {} exceeds file size {}",
            current_byte_offset, file_size
        )));
    }

    // =========================================================================
    // EARLY RETURN: ALREADY AT EOF
    // =========================================================================

    // If cursor already at EOF, nowhere to move to
    if current_byte_offset >= file_size {
        return Ok((current_byte_offset, 0)); // Stay at EOF, no newlines
    }

    // =========================================================================
    // OPEN FILE FOR READING
    // =========================================================================

    let mut file = File::open(file_path).map_err(|e| {
        log_error(
            &format!("Cannot open file for word end movement: {}", e),
            Some("move_word_end"),
        );
        LinesError::Io(e)
    })?;

    // =========================================================================
    // INITIALIZE STATE
    // =========================================================================

    // Pre-allocated 1-byte buffer (stack only, no allocation)
    let mut byte_buffer: [u8; 1] = [0];

    // Current position during iteration
    let mut current_pos: u64 = current_byte_offset;

    // Newline counter (for window scrolling)
    let mut newlines_crossed: usize = 0;

    // =========================================================================
    // STEP 1: MOVE FORWARD 2 BYTES (ASSUMPTION: NEXT IS SYNTAX, SKIP IT)
    // =========================================================================

    // First move: skip 1 byte
    current_pos = current_pos.saturating_add(1);
    if current_pos >= file_size {
        return Ok((current_pos, newlines_crossed));
    }

    // Second move: skip another byte (assumption: it's syntax)
    // But we need to track if it's a newline
    file.seek(io::SeekFrom::Start(current_pos)).map_err(|e| {
        log_error(
            &format!(
                "Cannot seek to byte {} for word end initial move: {}",
                current_pos, e
            ),
            Some("move_word_end"),
        );
        LinesError::Io(e)
    })?;

    match file.read(&mut byte_buffer) {
        Ok(0) => {
            // EOF at this position
            return Ok((current_pos, newlines_crossed));
        }
        Ok(1) => {
            // Track if we're moving past a newline
            if byte_buffer[0] == b'\n' {
                newlines_crossed += 1;
            }
            current_pos = current_pos.saturating_add(1);
        }
        Ok(n) => {
            let error_msg = format!(
                "Unexpected read count {} at byte {} (expected 0 or 1)",
                n, current_pos
            );
            log_error(&error_msg, Some("move_word_end"));
            return Err(LinesError::Io(io::Error::new(
                io::ErrorKind::InvalidData,
                error_msg,
            )));
        }
        Err(e) => {
            log_error(
                &format!("Read error at byte {}: {}", current_pos, e),
                Some("move_word_end"),
            );
            return Err(LinesError::Io(e));
        }
    }

    // Check if we've gone past EOF after second move
    if current_pos >= file_size {
        return Ok((current_pos, newlines_crossed));
    }

    // =========================================================================
    // MAIN LOOP: PEEK AHEAD UNTIL NEXT BYTE IS SYNTAX
    // =========================================================================

    let mut iteration: usize = 0;

    loop {
        // Defensive: Check iteration limit
        if iteration >= WORD_MOVE_MAX_ITERATIONS {
            // Hit iteration limit - stop here
            log_error(
                &format!(
                    "Word end movement hit iteration limit at byte {}",
                    current_pos
                ),
                Some("move_word_end"),
            );
            return Ok((current_pos, newlines_crossed));
        }

        iteration += 1;

        // ===================================================================
        // PEEK AHEAD TO NEXT BYTE (BEFORE MOVING)
        // ===================================================================

        // Calculate next position
        let next_pos = current_pos.saturating_add(1);

        // Check if next position would be past EOF
        if next_pos >= file_size {
            // Next byte would be past EOF - stop here (cursor at current position)
            return Ok((current_pos, newlines_crossed));
        }

        // ===================================================================
        // READ NEXT BYTE (PEEK AHEAD)
        // ===================================================================

        // Seek to next position
        file.seek(io::SeekFrom::Start(next_pos)).map_err(|e| {
            log_error(
                &format!("Cannot seek to byte {} for word end peek: {}", next_pos, e),
                Some("move_word_end"),
            );
            LinesError::Io(e)
        })?;

        // Read one byte
        match file.read(&mut byte_buffer) {
            Ok(0) => {
                // EOF at next position - stop here
                return Ok((current_pos, newlines_crossed));
            }
            Ok(1) => {
                // Got one byte - check if it's syntax
                let next_byte = byte_buffer[0];

                match is_syntax_char(next_byte) {
                    Ok(true) => {
                        // Next byte IS syntax - STOP HERE (cursor stays before it)
                        return Ok((current_pos, newlines_crossed));
                    }
                    Ok(false) => {
                        // Next byte is non-syntax - move cursor forward to it
                        current_pos = next_pos;

                        // Check if we just moved through a newline
                        if next_byte == b'\n' {
                            newlines_crossed += 1;
                        }

                        // Continue loop to peek at the byte after this one
                        continue;
                    }
                    Err(e) => {
                        // Error checking syntax (shouldn't happen, but handle it)
                        log_error(
                            &format!("Error checking syntax at byte {}: {}", next_pos, e),
                            Some("move_word_end"),
                        );
                        return Err(e);
                    }
                }
            }
            Ok(n) => {
                // Unexpected: read() returned more than 1 byte for 1-byte buffer
                let error_msg = format!(
                    "Unexpected read count {} at byte {} (expected 0 or 1)",
                    n, next_pos
                );
                log_error(&error_msg, Some("move_word_end"));
                return Err(LinesError::Io(io::Error::new(
                    io::ErrorKind::InvalidData,
                    error_msg,
                )));
            }
            Err(e) => {
                // Read error - propagate
                log_error(
                    &format!("Read error at byte {}: {}", next_pos, e),
                    Some("move_word_end"),
                );
                return Err(LinesError::Io(e));
            }
        }
    }
}
/// Checks if the byte at a specific file position is a newline character
///
/// # Purpose
/// Safe, defensive helper function for peek-ahead operations. Used by movement
/// commands to detect when cursor would cross a line boundary without
/// moving or modifying state.
///
/// # Design Philosophy
/// - Single responsibility: just peek at one byte, answer yes/no
/// - Fail-safe: returns false on any error (doesn't panic or halt)
/// - Memory safe: no allocation, bounded I/O
/// - Used by: move_word_forward, move_word_end, move_word_back, and any other
///   movement that needs to detect line boundaries
///
/// # Arguments
/// * `file_path` - Absolute path to file being checked
///   - Must exist and be readable
///   - Defensive: caller responsible for validation
/// * `byte_pos` - Byte offset to check (0-indexed)
///   - Can be any value including >= file_size
///   - Defensive: out-of-bounds positions safely return false
/// * `file_size` - Total file size in bytes
///   - Used to validate byte_pos is in range
///   - If byte_pos >= file_size, returns false (EOF, not newline)
///
/// # Returns
/// * `Ok(true)` - Byte at position is 0x0A (newline)
/// * `Ok(false)` - Byte at position is not newline (any other byte or out-of-bounds)
/// * `Err(LinesError::Io)` - File operations failed (open, seek, read errors)
///
/// # Edge Cases Handled
/// - `byte_pos >= file_size` → returns `Ok(false)` (EOF is not newline)
/// - `byte_pos == file_size - 1` → reads last byte correctly
/// - File read returns 0 bytes → returns `Ok(false)` (EOF, not newline)
/// - File seek fails → returns `Err` (I/O error, logged)
/// - File read fails mid-operation → returns `Err` (I/O error, logged)
/// - Empty file (size 0) → returns `Ok(false)` (no bytes to read)
///
/// # Memory Safety
/// - Stack-only: 1-byte buffer allocated on stack
/// - No dynamic allocation
/// - No heap growth
/// - Single file open/seek/read/close per call
/// - Safe for UTF-8: newline is ASCII 0x0A, no multi-byte collision possible
///
/// # Performance
/// - Time: O(1) - single byte read (or fail fast)
/// - Space: O(1) - fixed 1-byte buffer
/// - I/O: 1 file open, 1 seek, 1 read, 1 close
/// - Suitable for calling in loops (bounded, cached pattern: peek before move)
///
/// # Defensive Programming
/// - All I/O errors logged with context
/// - No unwrap() or panic() calls
/// - Saturating arithmetic prevents overflow
/// - Early returns for out-of-bounds
/// - No assumptions about file state
///
/// # Use Cases
///
/// **Case 1: Peek-ahead in word movement**
/// ```ignore
/// // Before moving cursor, check if next byte is newline
/// if is_newline_at_position(&file_path, current_pos + 1, file_size)? {
///     // Crossed line boundary - use line nav instead
///     execute_command(state, Command::GotoLineStart)?;
///     execute_command(state, Command::MoveDown(1))?;
/// } else {
///     // Normal character movement
///     cursor.col += 1;
/// }
/// ```
///
/// **Case 2: Loop detection in move_word_forward**
/// ```ignore
/// while remaining_moves > 0 {
///     let next_pos = current_pos + 1;
///
///     if is_newline_at_position(&file_path, next_pos, file_size)? {
///         // Hit newline - stop or handle line crossing
///         return Ok((current_pos, newlines_crossed));
///     }
///
///     current_pos = next_pos;
///     remaining_moves -= 1;
/// }
/// ```
///
/// **Case 3: Integration with MoveRight command**
/// ```ignore
/// // In MoveRight loop: peek before scrolling right
/// if is_newline_at_position(&file_path, next_byte_pos, file_size)? {
///     execute_command(state, Command::GotoLineStart)?;
///     execute_command(state, Command::MoveDown(1))?;
/// } else {
///     state.tui_window_horizontal_utf8txt_line_char_offset += 1;
/// }
/// ```
///
/// # Integration Points
/// - `move_word_forward()`: Peek ahead to detect line crossing
/// - `move_word_end()`: Peek in loop to stop at syntax on next line
/// - `move_word_back()`: Peek backward to detect line crossing (reverse)
/// - `Command::MoveRight`: Peek before scrolling right (existing code)
/// - Any future movement command that needs line boundary detection
///
/// # Testing Strategy
/// Test with:
/// - File with newlines at various positions
/// - Empty file (no bytes)
/// - File with no newlines (single line)
/// - File with multiple consecutive newlines
/// - Position at EOF
/// - Position past EOF
/// - Position 0 (start of file)
/// - Last byte of file (EOF-1)
/// - Read-only files
/// - Binary files containing 0x0A bytes (not text)
///
/// # Performance Characteristics
/// - Suitable for per-move peek operations
/// - Not suitable for bulk newline scanning (use count_lines_in_file for that)
/// - Cost-benefit: single byte I/O vs. avoiding line-crossing bugs
///
/// # Error Policy
/// Following project error handling philosophy:
/// - File errors propagated (caller handles via ?)
/// - Logging happens before returning error
/// - Never silently swallows errors
/// - Caller responsible for retry/recovery logic
///
/// # Future Enhancement
/// Could cache results if same file peeked repeatedly, but:
/// - File may change between edits
/// - Invalidation logic complex
/// - Current per-call overhead minimal
/// - Premature optimization: keep simple unless profiling shows issue
///
pub fn is_newline_at_position(file_path: &Path, byte_pos: u64, file_size: u64) -> Result<bool> {
    // =========================================================================
    // INPUT VALIDATION
    // =========================================================================

    // Debug assert: path should be valid
    debug_assert!(
        !file_path.as_os_str().is_empty(),
        "File path cannot be empty in is_newline_at_position"
    );

    // Test assert: path should be valid
    #[cfg(test)]
    assert!(
        !file_path.as_os_str().is_empty(),
        "File path cannot be empty in is_newline_at_position"
    );

    // Production check: path empty
    if file_path.as_os_str().is_empty() {
        return Err(LinesError::InvalidInput("File path cannot be empty".into()));
    }

    // =========================================================================
    // EARLY RETURN: OUT OF BOUNDS
    // =========================================================================

    // Defensive: If position is at or past EOF, it's not a newline
    // This is the most common "false" case
    if byte_pos >= file_size {
        return Ok(false);
    }

    // =========================================================================
    // OPEN FILE FOR READING
    // =========================================================================

    let mut file = File::open(file_path).map_err(|e| {
        log_error(
            &format!(
                "Cannot open file to check for newline at byte {}: {}",
                byte_pos, e
            ),
            Some("is_newline_at_position"),
        );
        LinesError::Io(e)
    })?;

    // =========================================================================
    // SEEK TO POSITION AND READ SINGLE BYTE
    // =========================================================================

    // Pre-allocated 1-byte buffer (stack only, no allocation)
    let mut byte_buffer: [u8; 1] = [0];

    // Seek to the position we want to check
    file.seek(io::SeekFrom::Start(byte_pos)).map_err(|e| {
        log_error(
            &format!(
                "Cannot seek to byte {} in is_newline_at_position: {}",
                byte_pos, e
            ),
            Some("is_newline_at_position"),
        );
        LinesError::Io(e)
    })?;

    // Read one byte
    match file.read(&mut byte_buffer) {
        Ok(0) => {
            // EOF reached - no byte at this position (shouldn't happen after bounds check)
            log_error(
                &format!(
                    "Unexpected EOF when reading at byte {} (file_size was {})",
                    byte_pos, file_size
                ),
                Some("is_newline_at_position"),
            );
            Ok(false)
        }
        Ok(1) => {
            // Got one byte - check if it's a newline
            // Newline is ASCII 0x0A - safe single-byte check (no UTF-8 collision)
            Ok(byte_buffer[0] == b'\n')
        }
        Ok(n) => {
            // Unexpected: read() returned more than 1 byte for 1-byte buffer
            // This should never happen in safe Rust
            let error_msg = format!(
                "Unexpected read count {} at byte {} (expected 0 or 1)",
                n, byte_pos
            );
            log_error(&error_msg, Some("is_newline_at_position"));
            Err(LinesError::Io(io::Error::new(
                io::ErrorKind::InvalidData,
                error_msg,
            )))
        }
        Err(e) => {
            // Read error - propagate with context
            log_error(
                &format!(
                    "Read error at byte {} in is_newline_at_position: {}",
                    byte_pos, e
                ),
                Some("is_newline_at_position"),
            );
            Err(LinesError::Io(e))
        }
    }
}

    /// Retrieves the byte range for a display row
    ///
    /// # Purpose
    /// Gets stored line boundaries for cursor movement logic.
    ///
    /// # Arguments
    /// * `row` - Display row index (0-indexed)
    ///
    /// # Returns
    /// * `Ok(Some((start, end)))` - Line exists with these byte bounds
    /// * `Ok(None)` - Row not yet populated (empty window area)
    /// * `Err(io::Error)` - Row index out of bounds
    ///
    /// # Defensive Notes
    /// Returns error for invalid row, not silent None.
    /// Caller must distinguish between "row not populated" (Ok(None))
    /// and "invalid row index" (Err).
    pub fn get_line_byte_range(&self, row: usize) -> io::Result<Option<(u64, u64)>> {
        // Defensive: Validate row index
        if row >= MAX_TUI_ROWS {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!("Row {} exceeds maximum display rows {}", row, MAX_TUI_ROWS),
            ));
        }

        Ok(self.line_byte_start_end_position_pairs[row])
    }

    /// Checks if a file byte position is at the start of its line
    ///
    /// # Purpose
    /// Detects when cursor moves to line start for wrap-around behavior.
    /// When user presses 'h' (move left) at start of line,
    /// cursor should wrap to end of previous line.
    ///
    /// # Arguments
    /// * `row` - Current display row (0-indexed)
    /// * `byte_position` - File byte offset to check
    ///
    /// # Returns
    /// * `Ok(true)` - Byte is at start of this line
    /// * `Ok(false)` - Byte is NOT at line start (is middle or end)
    /// * `Err(io::Error)` - Row index invalid or range not set
    ///
    /// # Logic
    /// Checks if byte_position == line_start_byte of the row's range.
    ///
    /// # Example
    /// ```ignore
    /// // Line "hello\n" stored as (10, 15)
    /// is_at_line_start(0, 10)?  // true - at start
    /// is_at_line_start(0, 12)?  // false - in middle
    /// is_at_line_start(0, 15)?  // false - at end
    /// ```
    pub fn is_at_line_start(&self, row: usize, byte_position: u64) -> io::Result<bool> {
        // Get line boundaries (defensive: propagate error if row invalid)
        match self.get_line_byte_range(row)? {
            Some((start_byte, _end_byte)) => {
                // Compare byte position to line start
                Ok(byte_position == start_byte)
            }
            None => {
                // Row not populated - can't determine line start
                // Return false (not at line start of non-existent line)
                Ok(false)
            }
        }
    }

    /// Checks if a file byte position is at the end of its line
    ///
    /// # Purpose
    /// Detects when cursor moves to line end for wrap-around behavior.
    /// When user presses 'l' (move right) at end of line,
    /// cursor should wrap to start of next line.
    ///
    /// # Arguments
    /// * `row` - Current display row (0-indexed)
    /// * `byte_position` - File byte offset to check
    ///
    /// # Returns
    /// * `Ok(true)` - Byte is at end of this line (last content byte before newline)
    /// * `Ok(false)` - Byte is NOT at line end (is start or middle)
    /// * `Err(io::Error)` - Row index invalid or range not set
    ///
    /// # Logic
    /// Checks if byte_position == line_end_byte of the row's range.
    /// Note: end_byte is BEFORE the newline character, so cursor can be positioned there.
    ///
    /// # Empty Lines
    /// For empty line (start == end):
    /// - Position equals both start and end
    /// - Both `is_at_line_start()` and `is_at_line_end()` return true
    /// - Caller must handle this ambiguity (usually treated as both start and end)
    ///
    /// # Example
    /// ```ignore
    /// // Line "hello\n" stored as (10, 15)
    /// is_at_line_end(0, 10)?  // false - at start
    /// is_at_line_end(0, 12)?  // false - in middle
    /// is_at_line_end(0, 15)?  // true - at end
    ///
    /// // Empty line "\n" stored as (20, 20)
    /// is_at_line_end(1, 20)?  // true - at end (also at start)
    /// ```
    pub fn is_at_line_end(&self, row: usize, byte_position: u64) -> io::Result<bool> {
        // Get line boundaries (defensive: propagate error if row invalid)
        match self.get_line_byte_range(row)? {
            Some((_start_byte, end_byte)) => {
                // Compare byte position to line end
                Ok(byte_position == end_byte)
            }
            None => {
                // Row not populated - can't determine line end
                // Return false (not at line end of non-existent line)
                Ok(false)
            }
        }
    }

    /// Clears all line byte range tracking
    ///
    /// # Purpose
    /// Resets line boundary data when rebuilding window (e.g., after scroll).
    /// Called at start of `build_windowmap_nowrap()`.
    pub fn clear_line_byte_ranges(&mut self) {
        // Defensive: explicit loop with bounds (NASA Power of 10 Rule 2)
        for row in 0..MAX_TUI_ROWS {
            self.line_byte_start_end_position_pairs[row] = None;
        }
    }
}


windomap


    /// Retrieves the byte range for a display row
    ///
    /// # Purpose
    /// Gets stored line boundaries for cursor movement logic.
    ///
    /// # Arguments
    /// * `row` - Display row index (0-indexed)
    ///
    /// # Returns
    /// * `Ok(Some((start, end)))` - Line exists with these byte bounds
    /// * `Ok(None)` - Row not yet populated (empty window area)
    /// * `Err(io::Error)` - Row index out of bounds
    ///
    /// # Defensive Notes
    /// Returns error for invalid row, not silent None.
    /// Caller must distinguish between "row not populated" (Ok(None))
    /// and "invalid row index" (Err).
    pub fn get_line_byte_range(&self, row: usize) -> io::Result<Option<(u64, u64)>> {
        // Defensive: Validate row index
        if row >= MAX_TUI_ROWS {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!("Row {} exceeds maximum display rows {}", row, MAX_TUI_ROWS),
            ));
        }

        Ok(self.line_byte_start_end_position_pairs[row])
    }

    /// Checks if a file byte position is at the start of its line
    ///
    /// # Purpose
    /// Detects when cursor moves to line start for wrap-around behavior.
    /// When user presses 'h' (move left) at start of line,
    /// cursor should wrap to end of previous line.
    ///
    /// # Arguments
    /// * `row` - Current display row (0-indexed)
    /// * `byte_position` - File byte offset to check
    ///
    /// # Returns
    /// * `Ok(true)` - Byte is at start of this line
    /// * `Ok(false)` - Byte is NOT at line start (is middle or end)
    /// * `Err(io::Error)` - Row index invalid or range not set
    ///
    /// # Logic
    /// Checks if byte_position == line_start_byte of the row's range.
    ///
    /// # Example
    /// ```ignore
    /// // Line "hello\n" stored as (10, 15)
    /// is_at_line_start(0, 10)?  // true - at start
    /// is_at_line_start(0, 12)?  // false - in middle
    /// is_at_line_start(0, 15)?  // false - at end
    /// ```
    pub fn is_at_line_start(&self, row: usize, byte_position: u64) -> io::Result<bool> {
        // Get line boundaries (defensive: propagate error if row invalid)
        match self.get_line_byte_range(row)? {
            Some((start_byte, _end_byte)) => {
                // Compare byte position to line start
                Ok(byte_position == start_byte)
            }
            None => {
                // Row not populated - can't determine line start
                // Return false (not at line start of non-existent line)
                Ok(false)
            }
        }
    }

    /// Checks if a file byte position is at the end of its line
    ///
    /// # Purpose
    /// Detects when cursor moves to line end for wrap-around behavior.
    /// When user presses 'l' (move right) at end of line,
    /// cursor should wrap to start of next line.
    ///
    /// # Arguments
    /// * `row` - Current display row (0-indexed)
    /// * `byte_position` - File byte offset to check
    ///
    /// # Returns
    /// * `Ok(true)` - Byte is at end of this line (last content byte before newline)
    /// * `Ok(false)` - Byte is NOT at line end (is start or middle)
    /// * `Err(io::Error)` - Row index invalid or range not set
    ///
    /// # Logic
    /// Checks if byte_position == line_end_byte of the row's range.
    /// Note: end_byte is BEFORE the newline character, so cursor can be positioned there.
    ///
    /// # Empty Lines
    /// For empty line (start == end):
    /// - Position equals both start and end
    /// - Both `is_at_line_start()` and `is_at_line_end()` return true
    /// - Caller must handle this ambiguity (usually treated as both start and end)
    ///
    /// # Example
    /// ```ignore
    /// // Line "hello\n" stored as (10, 15)
    /// is_at_line_end(0, 10)?  // false - at start
    /// is_at_line_end(0, 12)?  // false - in middle
    /// is_at_line_end(0, 15)?  // true - at end
    ///
    /// // Empty line "\n" stored as (20, 20)
    /// is_at_line_end(1, 20)?  // true - at end (also at start)
    /// ```
    pub fn is_at_line_end(&self, row: usize, byte_position: u64) -> io::Result<bool> {
        // Get line boundaries (defensive: propagate error if row invalid)
        match self.get_line_byte_range(row)? {
            Some((_start_byte, end_byte)) => {
                // Compare byte position to line end
                Ok(byte_position == end_byte)
            }
            None => {
                // Row not populated - can't determine line end
                // Return false (not at line end of non-existent line)
                Ok(false)
            }
        }
    }

// // KEEP THIS
// /// Deletes single byte at specific file position
// ///
// /// # Overview
// ///
// /// This helper function removes one byte from a file by shifting all subsequent
// /// bytes left by one position, then truncating the file to new length.
// ///
// /// **Operation:**
// /// ```text
// /// Before: [A B C D E F]
// ///         Delete byte at position 3
// /// After:  [A B C E F]
// ///                 ↑ D removed, E shifted left
// /// ```
// ///
// /// # Memory Safety - Stack Allocated Buffer
// ///
// /// Uses 8KB stack buffer for shifting bytes after deletion point.
// /// - No heap allocation for data processing
// /// - Fixed-size buffer regardless of file size
// /// - If file has > 8KB after deletion point, shifts occur in 8KB chunks
// ///
// /// # Arguments
// ///
// /// * `file_path` - Path to target file (read+write access required)
// /// * `position` - Byte offset to delete (0 = first byte, file_size-1 = last byte)
// ///
// /// # Returns
// ///
// /// * `Ok(())` - Byte deleted successfully, file shortened by 1 byte
// /// * `Err(io::Error)` - File operation failed (open, seek, read, write, truncate, flush)
// ///
// /// # Algorithm
// ///
// /// 1. Open file in read+write mode
// /// 2. Seek to position+1 (first byte to keep)
// /// 3. Read bytes after deletion point into buffer (up to 8KB)
// /// 4. Seek back to deletion position
// /// 5. Write shifted bytes (from buffer)
// /// 6. Truncate file to new length (original - 1 byte)
// /// 7. Flush to ensure data written to disk
// ///
// /// # Edge Cases
// ///
// /// **Delete last byte (position == file_size - 1):**
// /// - Read after position+1 returns 0 bytes
// /// - Nothing to shift
// /// - File truncated by 1 byte
// /// - Most efficient case
// ///
// /// **Delete first byte (position == 0):**
// /// - Reads entire file into buffer (up to 8KB)
// /// - Writes at position 0 (original position 1 bytes)
// /// - All bytes shifted left
// /// - Most expensive case
// ///
// /// **Delete with > 8KB after deletion point:**
// /// - Only first 8KB shifted
// /// - **BUG:** Bytes beyond 8KB not shifted, file corrupted
// /// - Should loop-shift in chunks
// /// - Current implementation assumes remaining bytes < 8KB
// ///
// /// **Delete beyond EOF (position >= file_size):**
// /// - Read returns 0 bytes
// /// - Write does nothing
// /// - Truncate sets file size to position (might grow file!)
// /// - Unexpected behavior - should validate position < file_size
// ///
// /// **Empty file (file_size == 0):**
// /// - Any position is invalid
// /// - Read returns 0 bytes
// /// - Truncate sets size to position (creates zero-byte file)
// /// - Should error if file empty
// ///
// /// # Defensive Programming
// ///
// /// - No unwrap calls
// /// - All I/O operations explicitly error-checked
// /// - Truncate ensures file size reflects deletion
// /// - Flush called to ensure disk write
// ///
// /// # Performance
// ///
// /// - **Time:** O(M) where M = bytes after deletion point (up to 8KB)
// /// - **Space:** O(1) - fixed 8KB stack buffer
// /// - **I/O:** 1 read, 2 seeks, 1 write, 1 truncate, 1 flush = 6 operations
// /// - Not optimized for repeated deletions (each call shifts independently)
// ///
// /// # Known Limitations
// ///
// /// **8KB shift buffer limit:**
// /// If file has > 8KB bytes after deletion point:
// /// - Only first 8KB shifted correctly
// /// - Data beyond 8KB lost
// /// - Should loop to shift all remaining bytes
// ///
// /// **No validation:**
// /// Doesn't check if position is valid (< file_size)
// /// Invalid position causes undefined behavior
// ///
// /// **No atomic operation:**
// /// If write or truncate fails mid-operation, file left inconsistent.
// /// No rollback mechanism.
// ///
// /// # See Also
// ///
// /// * `insert_bytes_at_position()` - Inverse operation (adds bytes)
// /// * `insert_file_at_cursor()` - Caller that uses this for final byte removal
// fn delete_byte_at_position(file_path: &Path, position: u64) -> io::Result<()> {
//     // Open file for read+write
//     // Requires file already exists
//     let mut file = OpenOptions::new().read(true).write(true).open(file_path)?;

//     // Pre-allocated buffer for bytes after deletion point
//     // 8KB chosen as balance between stack usage and shift efficiency
//     const BUFFER_SIZE: usize = 8192;
//     let mut after_buffer = [0u8; BUFFER_SIZE];

//     // Seek to position+1 (skip the byte being deleted)
//     // Read bytes that need to be shifted left
//     file.seek(SeekFrom::Start(position + 1))?;
//     let bytes_after = file.read(&mut after_buffer)?;

//     // Seek back to deletion position
//     // Write the shifted bytes starting at deletion position
//     file.seek(SeekFrom::Start(position))?;
//     file.write_all(&after_buffer[..bytes_after])?;

//     // Truncate file to new length (original size - 1 byte)
//     // This removes the duplicate byte at end that resulted from shift-left
//     let new_length = position + bytes_after as u64;
//     file.set_len(new_length)?;

//     // Flush to ensure data written to disk
//     file.flush()?;

//     Ok(())
// }

    // /// Checks if cursor is at the end of its current line
    // ///
    // /// # Purpose
    // /// Uses cursor position already in state to determine line end.
    // /// Used for move-right wrapping: when user presses 'l' at line end,
    // /// cursor wraps to start of next line.
    // ///
    // /// # Returns
    // /// * `Ok(true)` - Cursor is at the last byte of current line
    // /// * `Ok(false)` - Cursor is NOT at line end
    // /// * `Err(LinesError)` - Cannot determine (state error or invalid position)
    // ///
    // /// # Defensive
    // /// All lookups must succeed - returns error if data missing or invalid
    // pub fn is_cursor_at_line_end(&self) -> Result<bool> {
    //     // Get line byte range for current row
    //     let (_start_byte, end_byte) = self.window_map.line_byte_start_end_position_pairs
    //         [self.cursor.row]
    //         .ok_or_else(|| {
    //             let msg = format!("Line byte range not set for row {}", self.cursor.row);
    //             log_error(&msg, Some("is_cursor_at_line_end"));
    //             LinesError::StateError(msg)
    //         })?;

    //     // Get cursor's file byte position
    //     let cursor_byte_offset = self
    //         .window_map
    //         .get_row_col_file_position(self.cursor.row, self.cursor.col)?
    //         .ok_or_else(|| {
    //             let msg = format!(
    //                 "Cursor at ({}, {}) maps to empty cell",
    //                 self.cursor.row, self.cursor.col
    //             );
    //             log_error(&msg, Some("is_cursor_at_line_end"));
    //             LinesError::StateError(msg)
    //         })?
    //         .byte_offset_linear_file_absolute_position;

    //     // Defensive: cursor should never exceed line end
    //     if cursor_byte_offset > end_byte {
    //         let msg = format!(
    //             "Cursor byte {} exceeds line end {} (row {}, col {})",
    //             cursor_byte_offset, end_byte, self.cursor.row, self.cursor.col
    //         );
    //         log_error(&msg, Some("is_cursor_at_line_end"));
    //         return Err(LinesError::StateError(msg));
    //     }

    //     Ok(cursor_byte_offset == end_byte)
    // }

    /// Checks if cursor is at the start of its current line
    ///
    /// # Purpose
    /// Uses cursor position already in state to determine line start.
    /// Used for move-left wrapping: when user presses 'h' at line start,
    /// cursor wraps to end of previous line.
    ///
    /// # Returns
    /// * `Ok(true)` - Cursor is at the first byte of current line
    /// * `Ok(false)` - Cursor is NOT at line start
    /// * `Err(LinesError)` - Cannot determine (state error or invalid position)
    ///
    /// # Defensive
    /// All lookups must succeed - returns error if data missing or invalid
    pub fn is_cursor_at_line_start(&self) -> Result<bool> {
        // Get line byte range for current row
        let (start_byte, _end_byte) = self.window_map.line_byte_start_end_position_pairs
            [self.cursor.row]
            .ok_or_else(|| {
                let msg = format!("Line byte range not set for row {}", self.cursor.row);
                log_error(&msg, Some("is_cursor_at_line_start"));
                LinesError::StateError(msg)
            })?;

        // Get cursor's file byte position
        let cursor_byte_offset = self
            .window_map
            .get_row_col_file_position(self.cursor.row, self.cursor.col)?
            .ok_or_else(|| {
                let msg = format!(
                    "Cursor at ({}, {}) maps to empty cell",
                    self.cursor.row, self.cursor.col
                );
                log_error(&msg, Some("is_cursor_at_line_start"));
                LinesError::StateError(msg)
            })?
            .byte_offset_linear_file_absolute_position;

        // Defensive: cursor should never be before line start
        if cursor_byte_offset < start_byte {
            let msg = format!(
                "Cursor byte {} is before line start {} (row {}, col {})",
                cursor_byte_offset, start_byte, self.cursor.row, self.cursor.col
            );
            log_error(&msg, Some("is_cursor_at_line_start"));
            return Err(LinesError::StateError(msg));
        }

        Ok(cursor_byte_offset == start_byte)
    }

}

    #[test]
    fn test_calculate_display_width() {
        assert_eq!(calculate_display_width("Hello"), Some(5));
        assert_eq!(calculate_display_width("你好"), Some(4));
        assert_eq!(calculate_display_width("Hello世界"), Some(9));
        assert_eq!(calculate_display_width(""), Some(0));
        assert_eq!(calculate_display_width("ＡＢＣ"), Some(6));
    }

    #[test]
    fn test_mixed_width_string() {
        let mixed = "Hello 世界 World";
        let expected = 5 + 1 + 2 + 2 + 1 + 5; // "Hello" + " " + "世界" + " " + "World"
        assert_eq!(calculate_display_width(mixed), Some(expected));
    }
        let display_width =
            double_width::calculate_display_width(content).expect("Should calculate width");
        assert_eq!(display_width, 10, "Should be 10 display columns total");

        // Display width should fit within terminal
        let row_display_width = double_width::calculate_display_width(first_row_str)
            .expect("Should calculate display width");
        assert!(
            row_display_width <= 80,
            "Display width {} should not exceed terminal width 80",
            row_display_width
        );

    // /// Checks if a file byte position is at the end of its line
    // ///
    // /// # Purpose
    // /// Detects when cursor moves to line end for wrap-around behavior.
    // /// When user presses 'l' (move right) at end of line,
    // /// cursor should wrap to start of next line.
    // ///
    // /// # Arguments
    // /// * `row` - Current display row (0-indexed)
    // /// * `byte_position` - File byte offset to check
    // ///
    // /// # Returns
    // /// * `Ok(true)` - Byte is at end of this line (last content byte before newline)
    // /// * `Ok(false)` - Byte is NOT at line end (is start or middle)
    // /// * `Err(io::Error)` - Row index invalid or range not set
    // ///
    // /// # Logic
    // /// Checks if byte_position == line_end_byte of the row's range.
    // /// Note: end_byte is BEFORE the newline character, so cursor can be positioned there.
    // ///
    // /// # Empty Lines
    // /// For empty line (start == end):
    // /// - Position equals both start and end
    // /// - Both `is_at_line_start()` and `is_at_line_end()` return true
    // /// - Caller must handle this ambiguity (usually treated as both start and end)
    // ///
    // /// # Example
    // /// ```ignore
    // /// // Line "hello\n" stored as (10, 15)
    // /// is_at_line_end(0, 10)?  // false - at start
    // /// is_at_line_end(0, 12)?  // false - in middle
    // /// is_at_line_end(0, 15)?  // true - at end
    // ///
    // /// // Empty line "\n" stored as (20, 20)
    // /// is_at_line_end(1, 20)?  // true - at end (also at start)
    // /// ```
    // pub fn is_at_line_end(&self, row: usize, byte_position: u64) -> io::Result<bool> {
    //     // Get line boundaries (defensive: propagate error if row invalid)
    //     match self.get_line_byte_range(row)? {
    //         Some((_start_byte, end_byte)) => {
    //             // Compare byte position to line end
    //             Ok(byte_position == end_byte)
    //         }
    //         None => {
    //             // Row not populated - can't determine line end
    //             // Return false (not at line end of non-existent line)
    //             Ok(false)
    //         }
    //     }
    // }


works but does not check for existing time-match file
// /// Creates a read-only copy of the file in the session directory
// ///
// /// # Purpose
// /// Creates a timestamped copy in the session directory that won't be modified
// /// during editing. This prevents corruption if the editor crashes while writing.
// /// Read-copies are VISIBLE (no hidden files) and located in session directory
// /// for easy access and crash recovery.
// ///
// /// # Arguments
// /// * `original_path` - Path to the original file
// /// * `session_dir` - Path to this session's directory (from EditorState)
// ///
// /// # Returns
// /// * `Ok(PathBuf)` - Path to the read-copy in session directory
// /// * `Err(io::Error)` - Copy operation failed
// ///
// /// # File Naming
// /// Original: `/path/to/file.txt`
// /// Session dir: `{executable_dir}/lines_data/sessions/2025_01_15_14_30_45/`
// /// Read-copy: `{session_dir}/2025_01_15_14_30_45_file.txt`
// ///
// /// # Design Notes
// /// - NO hidden files (no leading dot) - files should be visible to user
// /// - Stored in session directory for crash recovery
// /// - Timestamp prefix ensures uniqueness
// /// - Session directory persists after exit for recovery
// pub fn create_a_readcopy_of_file(
//     original_path: &Path,
//     session_dir: &Path,
//     session_time_stamp: String,
// ) -> io::Result<PathBuf> {
//     // Defensive: Validate inputs
//     if !original_path.exists() {
//         return Err(io::Error::new(
//             io::ErrorKind::NotFound,
//             "Original file does not exist",
//         ));
//     }

//     if !session_dir.exists() || !session_dir.is_dir() {
//         return Err(io::Error::new(
//             io::ErrorKind::NotFound,
//             "Session directory does not exist",
//         ));
//     }

//     // Get original filename
//     let file_name = original_path
//         .file_name()
//         .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidInput, "Cannot determine filename"))?
//         .to_string_lossy();

//     // Build read-copy filename: {timestamp}_{original_filename}
//     // NO leading dot - file should be visible

//     // let read_copy_name = format!("{}_{}", session_time_stamp, file_name);
//     // let read_copy_path = session_dir.join(&read_copy_name);
//     let st_formatted_read_copy_path =
//         stack_format_it("{}_{}", &[&session_time_stamp, &file_name], "N_N");
//     let read_copy_path = session_dir.join(&st_formatted_read_copy_path);

//     // If read-copy already exists, return it immediately (idempotent)
//     if read_copy_path.exists() {
//         return Ok(read_copy_path);
//     }

//     // Copy the file to session directory
//     fs::copy(original_path, &read_copy_path).map_err(|e| {
//         io::Error::new(
//             io::ErrorKind::Other,
//             format!("Failed to create read-copy: {}", e),
//         )
//     })?;

//     // Defensive: Verify copy succeeded
//     if !read_copy_path.exists() {
//         return Err(io::Error::new(
//             io::ErrorKind::Other,
//             "Read-copy creation reported success but file not found",
//         ));
//     }

//     // // Diagnostic Log success for user visibility
//     // println!("Read-copy created: {}", read_copy_path.display());

//     // Assertion: Verify result is valid
//     debug_assert!(
//         read_copy_path.is_absolute(),
//         "Read-copy path should be absolute"
//     );
//     debug_assert!(
//         read_copy_path.exists(),
//         "Read-copy should exist after creation"
//     );

//     Ok(read_copy_path)
// }

/// Formats a message with multiple variable parts inserted at {} placeholders.
///
/// ## Project Context
/// Provides simple string formatting for UI messages and error messages using
/// stack-allocated buffers. Designed for display text where formatting failure
/// can gracefully degrade to a fallback message without compromising program
/// operation.
///
/// **Use for:**
/// - Status bar updates
/// - User notifications
/// - Progress indicators
/// - Display-only error messages
///
/// **Do NOT use for:**
/// - output that may exceed a known size
/// - where a known default is less optimal than erroring-out
///
/// Stack allocation makes this function safer and more predictable than
/// heap-based formatting for bounded display messages.
///
/// ## Operation
/// Takes a template string with one or more "{}" placeholders and inserts variable
/// strings in order. Processes each placeholder sequentially, replacing with the
/// corresponding insert string.
///
/// Examples:
/// - stack_format_it("inserted {} bytes", &["42"]) -> "inserted 42 bytes"
/// - stack_format_it("range: start={} > end={}", &["10", "5"]) -> "range: start=10 > end=5"
/// - stack_format_it("a {} b {} c {}", &["1", "2", "3"]) -> "a 1 b 2 c 3"
///
/// ## Safety & Error Handling
/// - No panic: Always returns a valid string (formatted or fallback)
/// - No unwrap: Direct return, no Result to unwrap
/// - Uses 256-byte stack buffer for formatting
/// - Returns fallback if result exceeds buffer size
/// - Returns fallback if placeholder count doesn't match insert count
/// - Returns fallback if template has no {} placeholders
/// - Maximum 8 inserts supported (configurable via MAX_INSERTS)
///
/// ## Parameters
/// - `template`: String with one or more "{}" placeholders
/// - `inserts`: Slice of strings to insert at placeholders (in order)
/// - `fallback`: Message to return if formatting fails
///
/// ## Returns
/// Formatted string on success, fallback string on any error (always valid)
///
/// ## Use Examples:
/// ```rust
/// let bytes = total_bytes_written.saturating_sub(1);
/// let num_str = bytes.to_string();
/// let message = stack_format_it("inserted {} bytes", &[&num_str], "inserted data");
/// ```
///
/// Error Formatting:
/// ```
/// io::stdout().flush().map_err(|e| {
///     LinesError::DisplayError(stack_format_it(
///         "Failed to flush stdout: {}",
///         &[&e.to_string()],
///         "Failed to flush stdout",
///     ))
/// })?;
/// ```
///
/// ```rust
/// let num_1 = start_byte.to_string();
/// let num_2 = end_byte.to_string();
/// let formatted_string = stack_format_it(
///     "Invalid byte range: start={} > end={}",
///     &[&num_1, &num_2],
///     "Invalid byte range"
/// );
/// ```
fn stack_format_it1(template: &str, inserts: &[&str], fallback: &str) -> String {
    // Internal stack buffer for result
    let mut buf = [0u8; 256];

    // Maximum number of inserts to prevent abuse
    const MAX_INSERTS: usize = 128;

    // Check insert count
    if inserts.is_empty() {
        #[cfg(debug_assertions)]
        eprintln!("stack_format_it: No inserts provided");
        return fallback.to_string();
    }

    if inserts.len() > MAX_INSERTS {
        #[cfg(debug_assertions)]
        eprintln!("stack_format_it: Too many inserts (max {})", MAX_INSERTS);
        return fallback.to_string();
    }

    // Count placeholders in template
    let placeholder = "{}";
    let placeholder_count = template.matches(placeholder).count();

    if placeholder_count == 0 {
        #[cfg(debug_assertions)]
        eprintln!("stack_format_it: No '{{}}' placeholders found in template");
        return fallback.to_string();
    }

    if placeholder_count != inserts.len() {
        #[cfg(debug_assertions)]
        eprintln!(
            "stack_format_it: Placeholder count ({}) doesn't match insert count ({})",
            placeholder_count,
            inserts.len()
        );
        return fallback.to_string();
    }

    // Calculate total length needed
    let mut total_len = template.len();

    // Subtract placeholder lengths
    total_len = match total_len.checked_sub(placeholder.len() * placeholder_count) {
        Some(len) => len,
        None => {
            #[cfg(debug_assertions)]
            eprintln!("stack_format_it: Length calculation underflow");
            return fallback.to_string();
        }
    };

    // Add insert lengths
    for insert in inserts {
        total_len = match total_len.checked_add(insert.len()) {
            Some(len) => len,
            None => {
                #[cfg(debug_assertions)]
                eprintln!("stack_format_it: Length overflow");
                return fallback.to_string();
            }
        };
    }

    // Check buffer capacity
    if total_len > buf.len() {
        #[cfg(debug_assertions)]
        eprintln!(
            "stack_format_it: Result too large (need {}, have {})",
            total_len,
            buf.len()
        );
        return fallback.to_string();
    }

    // Build the result by processing each placeholder
    let mut pos = 0;
    let mut remaining_template = template;
    let mut insert_idx = 0;

    while let Some(placeholder_pos) = remaining_template.find(placeholder) {
        // Copy text before placeholder
        let before = &remaining_template[..placeholder_pos];
        if pos + before.len() > buf.len() {
            #[cfg(debug_assertions)]
            eprintln!("stack_format_it: Buffer overflow during copy");
            return fallback.to_string();
        }
        buf[pos..pos + before.len()].copy_from_slice(before.as_bytes());
        pos += before.len();

        // Copy insert
        let insert = inserts[insert_idx];
        if pos + insert.len() > buf.len() {
            #[cfg(debug_assertions)]
            eprintln!("stack_format_it: Buffer overflow during insert");
            return fallback.to_string();
        }
        buf[pos..pos + insert.len()].copy_from_slice(insert.as_bytes());
        pos += insert.len();

        // Move to next segment
        remaining_template = &remaining_template[placeholder_pos + placeholder.len()..];
        insert_idx += 1;
    }

    // Copy remaining text after last placeholder
    if pos + remaining_template.len() > buf.len() {
        #[cfg(debug_assertions)]
        eprintln!("stack_format_it: Buffer overflow during final copy");
        return fallback.to_string();
    }
    buf[pos..pos + remaining_template.len()].copy_from_slice(remaining_template.as_bytes());
    pos += remaining_template.len();

    // Validate UTF-8 and return
    match std::str::from_utf8(&buf[..pos]) {
        Ok(s) => s.to_string(),
        Err(_) => {
            #[cfg(debug_assertions)]
            eprintln!("stack_format_it: Invalid UTF-8 in result");
            fallback.to_string()
        }
    }
}

// /// Creates a read-only copy of the file in the session directory
// ///
// /// # Purpose
// /// Creates a timestamped copy in the session directory that won't be modified
// /// during editing. This prevents corruption if the editor crashes while writing.
// /// Read-copies are VISIBLE (no hidden files) and located in session directory
// /// for easy access and crash recovery.
// ///
// /// # Arguments
// /// * `original_path` - Path to the original file
// /// * `session_dir` - Path to this session's directory (from EditorState)
// ///
// /// # Returns
// /// * `Ok(PathBuf)` - Path to the read-copy in session directory
// /// * `Err(io::Error)` - Copy operation failed
// ///
// /// # File Naming
// /// Original: `/path/to/file.txt`
// /// Session dir: `{executable_dir}/lines_data/sessions/2025_01_15_14_30_45/`
// /// Read-copy: `{session_dir}/2025_01_15_14_30_45_file.txt`
// ///
// /// # Design Notes
// /// - NO hidden files (no leading dot) - files should be visible to user
// /// - Stored in session directory for crash recovery
// /// - Timestamp prefix ensures uniqueness
// /// - Session directory persists after exit for recovery
// pub fn create_a_readcopy_of_file(
//     original_path: &Path,
//     session_dir: &Path,
//     session_time_stamp: String,
// ) -> io::Result<PathBuf> {
//     // Defensive: Validate inputs
//     if !original_path.exists() {
//         return Err(io::Error::new(
//             io::ErrorKind::NotFound,
//             "Original file does not exist",
//         ));
//     }

//     if !session_dir.exists() || !session_dir.is_dir() {
//         return Err(io::Error::new(
//             io::ErrorKind::NotFound,
//             "Session directory does not exist",
//         ));
//     }

//     // Get original filename
//     let file_name = original_path
//         .file_name()
//         .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidInput, "Cannot determine filename"))?
//         .to_string_lossy();

//     // Build read-copy filename: {timestamp}_{original_filename}
//     // NO leading dot - file should be visible

//     // let read_copy_name = format!("{}_{}", session_time_stamp, file_name);
//     // let read_copy_path = session_dir.join(&read_copy_name);
//     let st_formatted_read_copy_path =
//         stack_format_it("{}_{}", &[&session_time_stamp, &file_name], "N_N");
//     let read_copy_path = session_dir.join(&st_formatted_read_copy_path);

//     // If read-copy already exists, return it immediately (idempotent)
//     if read_copy_path.exists() {
//         return Ok(read_copy_path);
//     }

//     // Copy the file to session directory
//     fs::copy(original_path, &read_copy_path).map_err(|e| {
//         io::Error::new(
//             io::ErrorKind::Other,
//             format!("Failed to create read-copy: {}", e),
//         )
//     })?;

//     // Defensive: Verify copy succeeded
//     if !read_copy_path.exists() {
//         return Err(io::Error::new(
//             io::ErrorKind::Other,
//             "Read-copy creation reported success but file not found",
//         ));
//     }

//     // // Diagnostic Log success for user visibility
//     // println!("Read-copy created: {}", read_copy_path.display());

//     // Assertion: Verify result is valid
//     debug_assert!(
//         read_copy_path.is_absolute(),
//         "Read-copy path should be absolute"
//     );
//     debug_assert!(
//         read_copy_path.exists(),
//         "Read-copy should exist after creation"
//     );

//     Ok(read_copy_path)
// }

// /// Creates a read-only copy of the file in the session directory
// ///
// /// # Purpose
// /// Creates a timestamped copy in the session directory that won't be modified
// /// during editing. This prevents corruption if the editor crashes while writing.
// /// Read-copies are VISIBLE (no hidden files) and located in session directory
// /// for easy access and crash recovery.
// ///
// /// # Behavior - Session Directory Timestamp Matching
// /// 1. Extracts timestamp from session directory name (e.g., from `2025_01_15_14_30_45/`)
// /// 2. Checks if file already exists with session directory's timestamp prefix
// /// 3. If found: Returns existing file (prevents duplicate copies in same session)
// /// 4. If not found: Creates new copy with input timestamp prefix
// ///
// /// This ensures files within a session directory use that session's timestamp,
// /// preventing duplicate copies when reopening the same file in the same session.
// ///
// /// # Arguments
// /// * `original_path` - Path to the original file
// /// * `session_dir` - Path to this session's directory (from EditorState)
// /// * `session_time_stamp` - Timestamp to use if creating new copy
// ///
// /// # Returns
// /// * `Ok(PathBuf)` - Path to the read-copy in session directory (existing or new)
// /// * `Err(io::Error)` - Copy operation failed or validation failed
// ///
// /// # File Naming
// /// Original: `/path/to/file.txt`
// /// Session dir: `{executable_dir}/lines_data/sessions/2025_01_15_14_30_45/`
// /// Read-copy: `{session_dir}/2025_01_15_14_30_45_file.txt`
// ///
// /// # Design Notes
// /// - NO hidden files (no leading dot) - files should be visible to user
// /// - Stored in session directory for crash recovery
// /// - Timestamp prefix ensures uniqueness
// /// - Session directory persists after exit for recovery
// /// - Reuses existing timestamped copies within same session
// /// - Falls back gracefully if parent directory timestamp cannot be extracted
// pub fn create_a_readcopy_of_file(
//     original_path: &Path,
//     session_dir: &Path,
//     session_time_stamp: String,
// ) -> io::Result<PathBuf> {
//     // Defensive: Validate inputs
//     if !original_path.exists() {
//         return Err(io::Error::new(
//             io::ErrorKind::NotFound,
//             "create_a_readcopy_of_file: Original file does not exist",
//         ));
//     }

//     if !session_dir.exists() || !session_dir.is_dir() {
//         return Err(io::Error::new(
//             io::ErrorKind::NotFound,
//             "create_a_readcopy_of_file: Session directory does not exist",
//         ));
//     }

//     // Get original filename
//     let file_name = original_path
//         .file_name()
//         .ok_or_else(|| {
//             io::Error::new(
//                 io::ErrorKind::InvalidInput,
//                 "create_a_readcopy_of_file: Cannot determine filename",
//             )
//         })?
//         .to_string_lossy();

//     // ===================================================================
//     // STEP 1: Extract timestamp from parent session directory name
//     // ===================================================================
//     // Session directories are named with timestamps (e.g., "2025_01_15_14_30_45")
//     // Extract this to check if a file with that timestamp already exists
//     let parent_dir_name = session_dir
//         .file_name()
//         .and_then(|os_str| os_str.to_str())
//         .unwrap_or("");

//     // Debug assertion: Directory name should not be empty in normal operation
//     debug_assert!(
//         !parent_dir_name.is_empty(),
//         "Session directory should have a valid name"
//     );

//     // ===================================================================
//     // STEP 2: Check if file with parent directory timestamp exists
//     // ===================================================================
//     // Format: {session_dir}/{parent_dir_timestamp}_{original_filename}
//     // If exists, return it (prevents duplicate copies in same session)
//     if !parent_dir_name.is_empty() {
//         let st_formatted_parent_timestamp_path =
//             stack_format_it("{}_{}", &[parent_dir_name, &file_name], "N_N");
//         let parent_timestamp_file_path = session_dir.join(&st_formatted_parent_timestamp_path);

//         // If file with parent directory's timestamp exists, return it
//         if parent_timestamp_file_path.exists() {
//             // Debug assertion: Verify path is absolute
//             debug_assert!(
//                 parent_timestamp_file_path.is_absolute(),
//                 "Existing file path should be absolute"
//             );

//             return Ok(parent_timestamp_file_path);
//         }
//     }

//     // ===================================================================
//     // STEP 3: File with parent timestamp not found - create with input timestamp
//     // ===================================================================
//     // Build read-copy filename: {input_timestamp}_{original_filename}
//     // NO leading dot - file should be visible
//     let st_formatted_read_copy_path =
//         stack_format_it("{}_{}", &[&session_time_stamp, &file_name], "N_N");
//     let read_copy_path = session_dir.join(&st_formatted_read_copy_path);

//     // If read-copy already exists with input timestamp, return it (idempotent)
//     if read_copy_path.exists() {
//         return Ok(read_copy_path);
//     }

//     // Copy the file to session directory
//     fs::copy(original_path, &read_copy_path).map_err(|e| {
//         io::Error::new(
//             io::ErrorKind::Other,
//             // format!(
//             //     "create_a_readcopy_of_file: Failed to create read-copy: {}",
//             //     e
//             // ),
//             stack_format_it(
//                 "create_a_readcopy_of_file: Failed to create read-copy: {}",
//                 &[&e.to_string()],
//                 "create_a_readcopy_of_file: Failed to create read-copy",
//             ),
//         )
//     })?;

//     // Defensive: Verify copy succeeded
//     if !read_copy_path.exists() {
//         return Err(io::Error::new(
//             io::ErrorKind::Other,
//             "create_a_readcopy_of_file: Read-copy creation reported success but file not found",
//         ));
//     }

//     // Assertion: Verify result is valid
//     debug_assert!(
//         read_copy_path.is_absolute(),
//         "Read-copy path should be absolute"
//     );
//     debug_assert!(
//         read_copy_path.exists(),
//         "Read-copy should exist after creation"
//     );

//     Ok(read_copy_path)
// }
    // // Create read-copy for safety
    // let _ = create_a_readcopy_of_file(&target_path, session_dir, session_time_stamp2.to_string())?;

        // ================
        // Bump on Main St.
        // ================
        /*
        To keep the cursor on the text:
        If on the top (zero index 0-line 0-row) bump to end of line number
        If not row zero, move to end of previous line.

        There may be periodic edge cases and bugs such as:
        - cursor goes to space in the number-zone (How ?)

        Question: width vs. +1
        Where should cursor.col = line_num_width + 1;
        vs.
        cursor.col = line_num_width;?

        */

        // // // find line text width
        // let line_num_width = calculate_line_number_width(
        //     lines_editor_state.line_count_at_top_of_window,
        //     lines_editor_state.cursor.tui_row,
        //     lines_editor_state.effective_rows,
        // );
        // if lines_editor_state.cursor.tui_col < line_num_width {
        //     // on line 0? (top) is cursor off the reservation? If so... Bump it Left!
        //     if lines_editor_state.cursor.tui_row == 0 {
        //         lines_editor_state.cursor.tui_col = line_num_width;
        //         lines_editor_state.in_row_abs_horizontal_0_index_cursor_position = line_num_width;
        //         lines_editor_state.tui_window_horizontal_utf8txt_line_char_offset = 0;

        //         build_windowmap_nowrap(&mut lines_editor_state, &read_copy)?;
        //     } else {
        //         // TODO add check to scroll up if not top of TUI
        //         if lines_editor_state.cursor.tui_row == 0 {}

        //         print!("moving up: line_num_width {line_num_width}");
        //         // Not at Top? If so... Bump it up!
        //         // Move up one line
        //         execute_command(&mut lines_editor_state, Command::MoveUp(1))?;

        //         // Move to end of that line
        //         execute_command(&mut lines_editor_state, Command::GotoLineEnd)?;

        //         build_windowmap_nowrap(&mut lines_editor_state, &read_copy)?;

        //         if lines_editor_state.cursor.tui_row == 0 {
        //             print!("pingping\n\n\n");
        //             lines_editor_state.cursor.tui_col = line_num_width + 1;
        //             lines_editor_state.in_row_abs_horizontal_0_index_cursor_position =
        //                 line_num_width + 1;
        //             lines_editor_state.tui_window_horizontal_utf8txt_line_char_offset = 0;
        //             execute_command(&mut lines_editor_state, Command::GotoLineEnd)?;
        //             build_windowmap_nowrap(&mut lines_editor_state, &read_copy)?;
        //             execute_command(&mut lines_editor_state, Command::GotoLineEnd)?;

        //             // let line_num_width = calculate_line_number_width(
        //             //     lines_editor_state.line_count_at_top_of_window,
        //             //     lines_editor_state.cursor.tui_row,
        //             //     lines_editor_state.effective_rows,
        //             // );

        //             // // if col is in the number-zone to the left of the text
        //             // // bump it over
        //             // if lines_editor_state.cursor.tui_col < line_num_width {
        //             //     lines_editor_state.cursor.tui_col = line_num_width; // Skip over line number displayfull_lines_editor
        //             //     build_windowmap_nowrap(&mut lines_editor_state, &read_copy)?;
        //             // }
        //         }

        //         // _ = build_windowmap_nowrap(&mut lines_editor_state, &read_copy); // rebuild
        //         let _ = lines_editor_state.set_info_bar_message("start of line"); // massage
        //     }
        // }



// // #[cfg(debug_assertions)]
// /// Determines the byte length of a UTF-8 character at a specific file position
// ///
// /// # Purpose (Project Context)
// /// Text editors must handle international text correctly. When detecting if
// /// the cursor is at a line end (for line-wrapping in cursor movement),
// /// we must know the COMPLETE character's byte span, not just its starting byte.
// ///
// /// For ASCII 'a' (1 byte), the character ends where it starts.
// /// For Chinese '世' (3 bytes: E4 B8 96), the character spans 3 bytes,
// /// so "next byte after character" is 3 bytes forward, not 1.
// ///
// /// This function enables correct line-end detection for all UTF-8 text.
// ///
// /// # Strategy
// /// 1. Opens file (stateless operation)
// /// 2. Seeks to target byte position
// /// 3. Reads first byte to examine UTF-8 pattern
// /// 4. Returns character length based on first-byte pattern
// /// 5. Closes file automatically (RAII)
// ///
// /// # UTF-8 First-Byte Patterns
// /// ```text
// /// Byte Range   Pattern      Character Length
// /// 0x00..=0x7F  0xxxxxxx     1 byte  (ASCII)
// /// 0xC0..=0xDF  110xxxxx     2 bytes
// /// 0xE0..=0xEF  1110xxxx     3 bytes
// /// 0xF0..=0xF7  11110xxx     4 bytes
// /// 0x80..=0xBF  10xxxxxx     Invalid (continuation byte, not first byte)
// /// 0xF8..=0xFF  11111xxx     Invalid (UTF-8 doesn't use these)
// /// ```
// ///
// /// # Arguments
// /// * `file_path` - Absolute path to file being analyzed
// /// * `byte_position` - Absolute byte offset in file where character starts
// ///
// /// # Returns
// /// * `Ok(1)` - Single-byte character (ASCII) OR invalid UTF-8 treated as 1 byte
// /// * `Ok(2)` - Two-byte UTF-8 character
// /// * `Ok(3)` - Three-byte UTF-8 character
// /// * `Ok(4)` - Four-byte UTF-8 character
// /// * `Err(LinesError::Io)` - Unrecoverable file I/O error (hardware failure)
// ///
// /// # Defensive Programming - Graceful Degradation
// /// Invalid UTF-8 sequences are treated as single bytes instead of crashing.
// /// This allows the editor to handle:
// /// - Corrupted files (bit flips, partial writes)
// /// - Binary data mixed with text
// /// - Files with encoding errors
// /// - Malicious or malformed input
// ///
// /// The editor continues operating; users can see and edit raw bytes.
// ///
// /// # Error Handling Philosophy
// /// - File not found → Returns `Err` (propagates to caller for logging)
// /// - Cannot open file → Returns `Err` (permission/hardware issue)
// /// - EOF at position → Returns `Ok(1)` (treat as single byte, defensive)
// /// - Invalid UTF-8 → Returns `Ok(1)` (treat as single byte, defensive)
// /// - Read I/O error → Returns `Err` (hardware failure)
// ///
// /// # Memory Allocation
// /// Zero heap allocation in critical path:
// /// - File handle on stack (dropped automatically)
// /// - Single-byte buffer `[u8; 1]` on stack
// /// - No string allocation
// /// - Error messages use string literals in production
// ///
// /// # Examples
// /// ```ignore
// /// // ASCII character 'a' (0x61)
// /// let len = get_utf8_char_byte_length_at_position(path, 10)?;
// /// assert_eq!(len, 1);
// ///
// /// // Chinese character '世' (0xE4 0xB8 0x96)
// /// let len = get_utf8_char_byte_length_at_position(path, 20)?;
// /// assert_eq!(len, 3);
// ///
// /// // Invalid byte (0x80 continuation byte at start)
// /// let len = get_utf8_char_byte_length_at_position(path, 30)?;
// /// assert_eq!(len, 1); // Defensive: treat as single byte
// /// ```
// fn get_utf8_char_byte_length_at_position(file_path: &Path, byte_position: u64) -> Result<usize> {
//     // ═══════════════════════════════════════════════════════════════════════
//     // DEFENSIVE CHECK 1: Validate file path is absolute
//     // ═══════════════════════════════════════════════════════════════════════
//     // Assertion: All file paths in this project must be absolute for security
//     // and clarity. Relative paths create ambiguity and security risks.
//     debug_assert!(
//         file_path.is_absolute(),
//         "File path must be absolute for UTF-8 character analysis"
//     );

//     if !file_path.is_absolute() {
//         #[cfg(debug_assertions)]
//         eprintln!(
//             "get_utf8_char_byte_length_at_position: non-absolute path rejected: {:?}",
//             file_path
//         );

//         return Err(LinesError::Io(io::Error::new(
//             io::ErrorKind::InvalidInput,
//             "File path must be absolute",
//         )));
//     }

//     // ═══════════════════════════════════════════════════════════════════════
//     // DEFENSIVE CHECK 2: Validate file exists before attempting to read
//     // ═══════════════════════════════════════════════════════════════════════
//     if !file_path.exists() {
//         #[cfg(debug_assertions)]
//         eprintln!(
//             "get_utf8_char_byte_length_at_position: file does not exist: {:?}",
//             file_path
//         );

//         return Err(LinesError::Io(io::Error::new(
//             io::ErrorKind::NotFound,
//             "File not found",
//         )));
//     }

//     // ═══════════════════════════════════════════════════════════════════════
//     // FILE OPERATION: Open file for reading (stateless operation)
//     // ═══════════════════════════════════════════════════════════════════════
//     // RAII: File handle automatically closed when function exits
//     let mut file = match File::open(file_path) {
//         Ok(f) => f,
//         Err(e) => {
//             #[cfg(debug_assertions)]
//             eprintln!(
//                 "get_utf8_char_byte_length_at_position: failed to open file {:?}: {}",
//                 file_path, e
//             );

//             // Propagate error - file access failure is unrecoverable here
//             return Err(LinesError::Io(e));
//         }
//     };

//     // ═══════════════════════════════════════════════════════════════════════
//     // FILE OPERATION: Seek to target byte position
//     // ═══════════════════════════════════════════════════════════════════════
//     if let Err(e) = file.seek(SeekFrom::Start(byte_position)) {
//         #[cfg(debug_assertions)]
//         eprintln!(
//             "get_utf8_char_byte_length_at_position: seek failed to position {}: {}",
//             byte_position, e
//         );

//         // Propagate error - seek failure indicates corrupted file or hardware issue
//         return Err(LinesError::Io(e));
//     }

//     // ═══════════════════════════════════════════════════════════════════════
//     // STACK ALLOCATION: Single-byte buffer for reading UTF-8 first byte
//     // ═══════════════════════════════════════════════════════════════════════
//     // No heap allocation: fixed-size stack buffer
//     let mut first_byte_buffer = [0u8; 1];

//     // ═══════════════════════════════════════════════════════════════════════
//     // FILE OPERATION: Read first byte of character
//     // ═══════════════════════════════════════════════════════════════════════
//     let bytes_read = match file.read(&mut first_byte_buffer) {
//         Ok(n) => n,
//         Err(e) => {
//             #[cfg(debug_assertions)]
//             eprintln!(
//                 "get_utf8_char_byte_length_at_position: read failed at position {}: {}",
//                 byte_position, e
//             );

//             // Propagate error - read failure indicates hardware/permission issue
//             return Err(LinesError::Io(e));
//         }
//     };

//     // ═══════════════════════════════════════════════════════════════════════
//     // DEFENSIVE CHECK 3: Handle EOF (cursor positioned at or past end of file)
//     // ═══════════════════════════════════════════════════════════════════════
//     if bytes_read == 0 {
//         #[cfg(debug_assertions)]
//         eprintln!(
//             "get_utf8_char_byte_length_at_position: EOF at position {} (treating as 1 byte)",
//             byte_position
//         );

//         // Defensive: Treat EOF as single byte
//         // This allows cursor movement logic to handle end-of-file gracefully
//         return Ok(1);
//     }

//     // ═══════════════════════════════════════════════════════════════════════
//     // UTF-8 ANALYSIS: Determine character length from first-byte pattern
//     // ═══════════════════════════════════════════════════════════════════════
//     let first_byte = first_byte_buffer[0];

//     // Assertion: We should have read exactly 1 byte if not EOF
//     debug_assert_eq!(bytes_read, 1, "Expected to read exactly 1 byte");

//     let char_length = if first_byte <= 0x7F {
//         // Pattern: 0xxxxxxx → 1-byte character (ASCII)
//         1
//     } else if first_byte >= 0xC0 && first_byte <= 0xDF {
//         // Pattern: 110xxxxx → 2-byte character
//         2
//     } else if first_byte >= 0xE0 && first_byte <= 0xEF {
//         // Pattern: 1110xxxx → 3-byte character
//         3
//     } else if first_byte >= 0xF0 && first_byte <= 0xF7 {
//         // Pattern: 11110xxx → 4-byte character
//         4
//     } else {
//         // Invalid UTF-8 first byte:
//         // - 0x80..=0xBF (continuation byte, not valid as first byte)
//         // - 0xF8..=0xFF (invalid UTF-8 range)
//         //
//         // Defensive: Treat as single byte, allow editor to continue
//         #[cfg(debug_assertions)]
//         eprintln!(
//             "get_utf8_char_byte_length_at_position: invalid UTF-8 first byte 0x{:02X} at position {} (treating as 1 byte)",
//             first_byte, byte_position
//         );

//         1 // Defensive fallback
//     };

//     // Assertion: Character length must be 1-4 (UTF-8 standard)
//     debug_assert!(
//         char_length >= 1 && char_length <= 4,
//         "UTF-8 character length must be 1-4 bytes, got {}",
//         char_length
//     );

//     Ok(char_length)
// }

    // #[cfg(debug_assertions)]
    // /// Determines if the next byte in the file is a newline character (line-end detection)
    // ///
    // /// # Purpose (Project Context)
    // /// This function supports text editor cursor movement in the MoveRight command.
    // /// When the cursor reaches the end of a line, the next byte is a newline character,
    // /// which signals that MoveRight should wrap to the next line instead of continuing right.
    // ///
    // /// # Multi-byte UTF-8 Support (PRIMARY FIX)
    // /// The critical insight: "next byte after cursor" depends on character size.
    // ///
    // /// For ASCII 'a' (1 byte):
    // /// ```text
    // /// Position: [10='a', 11='\n']
    // /// Cursor at 'a': cursor_byte=10, char_length=1, char_end=10
    // /// Next byte after 'a' is at position 11 (the newline)
    // /// ```
    // ///
    // /// For Chinese '世' (3 bytes: E4 B8 96):
    // /// ```text
    // /// Position: [10=E4, 11=B8, 12=96, 13='\n']
    // /// Cursor at '世': cursor_byte=10, char_length=3, char_end=12
    // /// Next byte after '世' is at position 13 (the newline)
    // /// ```
    // ///
    // /// **Previous Bug:** Compared `cursor_byte` (10) to `line_end_byte` (12) → FALSE ❌
    // /// **Fixed Logic:** Compare `cursor_char_end_byte` (12) to `line_end_byte` (12) → TRUE ✓
    // ///
    // /// # Scope - Graceful Out-of-Bounds Handling
    // /// **This function exists specifically to handle out-of-bounds conditions safely.**
    // /// Instead of crashing when the cursor is at invalid positions, it returns safe
    // /// default values that allow the application to continue operating:
    // ///
    // /// - No read-copy file path → Returns `Ok(false)` (cannot analyze, not at newline)
    // /// - Cursor row beyond file line count → Returns `Ok(false)` (treat as not at newline)
    // /// - Cursor column beyond line length → Returns `Ok(false)` (treat as not at newline)
    // /// - Line byte range not initialized → Returns `Ok(false)` (treat as not at newline)
    // /// - Cursor position unmapped in window → Returns `Ok(false)` (treat as not at newline)
    // /// - UTF-8 character read fails → Returns `Ok(false)` (cannot determine, not at newline)
    // ///
    // /// The philosophy: **When in doubt about boundaries, assume we're NOT at a newline.**
    // /// This prevents cursor movement commands from incorrectly wrapping lines, which is
    // /// safer than crashing the application.
    // ///
    // /// This function is stateless and read-only; it never modifies editor state.
    // ///
    // /// # Returns
    // /// * `Ok(true)` - Cursor is definitively at line-end; next file byte is the newline
    // /// * `Ok(false)` - Cursor is NOT at line-end, OR position is out-of-bounds/invalid
    // /// * `Err(LinesError::StateError)` - Only for truly unrecoverable internal corruption
    // ///
    // /// Note: Out-of-bounds conditions return `Ok(false)`, not errors. This allows the
    // /// application to continue safely without crashing on boundary conditions.
    // ///
    // /// # Algorithm
    // /// 1. Validate cursor row is within window bounds
    // /// 2. Get cursor's byte position in file from window map
    // /// 3. **Read UTF-8 character at cursor to get byte length**
    // /// 4. **Calculate last byte of cursor's character**
    // /// 5. Get line's end byte position from window map
    // /// 6. **Compare character-end to line-end** (not character-start)
    // /// 7. Return true if they match (next byte is newline)
    // ///
    // /// # Examples
    // /// ```ignore
    // /// // ASCII at line end
    // /// // File: "ab\n" where line_end_byte=11 (byte before newline)
    // /// // Cursor on 'b' at byte 11
    // /// let result = state.is_next_byte_newline()?;
    // /// assert_eq!(result, true); // Next byte (12) is newline
    // ///
    // /// // Multi-byte UTF-8 at line end
    // /// // File: "a世\n" where 世 is bytes 11-13, line_end_byte=13
    // /// // Cursor on '世' starting at byte 11
    // /// let result = state.is_next_byte_newline()?;
    // /// assert_eq!(result, true); // Character ends at 13, next byte (14) is newline
    // ///
    // /// // Not at line end
    // /// // File: "abc\n"
    // /// // Cursor on 'a'
    // /// let result = state.is_next_byte_newline()?;
    // /// assert_eq!(result, false); // Not at end of line
    // /// ```
    // pub fn is_next_byte_newline(&self) -> Result<bool> {
    //     // ═══════════════════════════════════════════════════════════════════════
    //     // DEFENSIVE CHECK 0: Verify read-copy file path exists
    //     // ═══════════════════════════════════════════════════════════════════════
    //     let read_copy_path = match &self.read_copy_path {
    //         Some(path) => path,
    //         None => {
    //             #[cfg(debug_assertions)]
    //             eprintln!(
    //                 "is_next_byte_newline: no read-copy file path available (returning false - not at newline)"
    //             );

    //             // Not an error - just means we cannot analyze the file
    //             return Ok(false);
    //         }
    //     };

    //     // ═══════════════════════════════════════════════════════════════════════
    //     // DEFENSIVE CHECK 1: Row bounds validation
    //     // ═══════════════════════════════════════════════════════════════════════
    //     // Instead of panicking on out-of-bounds, return Ok(false).
    //     // This is the PRIMARY PURPOSE of this function: handle boundaries gracefully.
    //     if self.cursor.tui_row >= self.windowmap_line_byte_start_end_position_pairs.len() {
    //         #[cfg(debug_assertions)]
    //         eprintln!(
    //             "is_next_byte_newline: cursor row {} >= line count {} (returning false - not at newline)",
    //             self.cursor.tui_row,
    //             self.windowmap_line_byte_start_end_position_pairs.len()
    //         );

    //         // Not an error - this is expected handling of out-of-bounds
    //         return Ok(false);
    //     }

    //     // ═══════════════════════════════════════════════════════════════════════
    //     // DEFENSIVE CHECK 2: Cursor position mapping validation
    //     // ═══════════════════════════════════════════════════════════════════════
    //     // If cursor doesn't map to a valid file position, safely return false.
    //     // This handles columns beyond line length without crashing.
    //     let cursor_byte_result =
    //         self.get_row_col_file_position(self.cursor.tui_row, self.cursor.tui_col)?;

    //     let cursor_byte_start = match cursor_byte_result {
    //         Some(pos) => pos.byte_offset_linear_file_absolute_position,
    //         None => {
    //             #[cfg(debug_assertions)]
    //             eprintln!(
    //                 "is_next_byte_newline: cursor ({}, {}) has no valid file position mapping (returning false - not at newline)",
    //                 self.cursor.tui_row, self.cursor.tui_col
    //             );

    //             // Not an error - cursor is just beyond valid positions
    //             return Ok(false);
    //         }
    //     };

    //     // ═══════════════════════════════════════════════════════════════════════
    //     // UTF-8 ANALYSIS: Determine byte length of character at cursor
    //     // ═══════════════════════════════════════════════════════════════════════
    //     // This is for multi-byte character support.
    //     // We must find where the character ends, not only where it starts.
    //     let char_byte_length = match get_utf8_char_byte_length_at_position(
    //         read_copy_path,
    //         cursor_byte_start,
    //     ) {
    //         Ok(len) => len,

    //         Err(_e) => {
    //             #[cfg(debug_assertions)]
    //             eprintln!(
    //                 "is_next_byte_newline: failed to read UTF-8 character at byte {}: {} (returning false - not at newline)",
    //                 cursor_byte_start, _e
    //             );

    //             // Defensive: If we can't read the character, assume not at line end
    //             // This allows cursor movement to continue safely
    //             return Ok(false);
    //         }
    //     };

    //     // Assertion: UTF-8 character length must be 1-4 bytes
    //     debug_assert!(
    //         char_byte_length >= 1 && char_byte_length <= 4,
    //         "UTF-8 character length must be 1-4, got {}",
    //         char_byte_length
    //     );

    //     // ═══════════════════════════════════════════════════════════════════════
    //     // CALCULATE: Last byte position of current character
    //     // ═══════════════════════════════════════════════════════════════════════
    //     // For 1-byte char at position 10: start=10, end=10
    //     // For 3-byte char at position 10: start=10, end=12
    //     let cursor_char_end_byte = cursor_byte_start + (char_byte_length as u64) - 1;

    //     // ═══════════════════════════════════════════════════════════════════════
    //     // DEFENSIVE CHECK 3: Line byte range access
    //     // ═══════════════════════════════════════════════════════════════════════
    //     // Use .get() for safe indexing. If somehow the row is still invalid,
    //     // return false (defense-in-depth: additional validation layer).
    //     let line_byte_range = match self
    //         .windowmap_line_byte_start_end_position_pairs
    //         .get(self.cursor.tui_row)
    //     {
    //         Some(range) => range,
    //         None => {
    //             #[cfg(debug_assertions)]
    //             eprintln!(
    //                 "is_next_byte_newline: line byte range missing for row {} (returning false - not at newline)",
    //                 self.cursor.tui_row
    //             );

    //             // Not an error - handle missing range gracefully
    //             return Ok(false);
    //         }
    //     };

    //     // ═══════════════════════════════════════════════════════════════════════
    //     // DEFENSIVE CHECK 4: Line byte range initialization
    //     // ═══════════════════════════════════════════════════════════════════════
    //     // The line_byte_range is an Option; if None, return false safely.
    //     let (_start, end) = match line_byte_range {
    //         Some(range) => *range,
    //         None => {
    //             #[cfg(debug_assertions)]
    //             eprintln!(
    //                 "is_next_byte_newline: line byte range is None (uninitialized) for row {} (returning false - not at newline)",
    //                 self.cursor.tui_row
    //             );

    //             // Not an error - uninitialized state handled gracefully
    //             return Ok(false);
    //         }
    //     };

    //     // ═══════════════════════════════════════════════════════════════════════
    //     // LOGIC: Determine if at line end (UTF-8-AWARE)
    //     // ═══════════════════════════════════════════════════════════════════════
    //     // If the LAST BYTE of the cursor's character equals the line's end byte,
    //     // then the next byte in the file is the newline character.
    //     //
    //     // Example with multi-byte character:
    //     //   Line: "ab世\n"
    //     //   Bytes: [10='a', 11='b', 12-14='世', 15='\n']
    //     //   line_end_byte = 14 (last content byte before newline)
    //     //
    //     //   When cursor is on '世':
    //     //     cursor_byte_start = 12
    //     //     char_byte_length = 3
    //     //     cursor_char_end_byte = 12 + 3 - 1 = 14
    //     //     cursor_char_end_byte (14) == line_end_byte (14) → TRUE
    //     //     Next byte (15) IS the newline → return Ok(true)
    //     //
    //     // This is the only condition where we return Ok(true).
    //     Ok(cursor_char_end_byte == end)
    // }
